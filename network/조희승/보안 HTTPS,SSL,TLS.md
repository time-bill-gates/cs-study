# 안전한 통신
- 안전한 통신의 목표 4가지
- 암호화
    - 수신자외 사람이 도청해서 읽기 못하도록 해야한다
- 무결성
    - 전송 도중 데이터 변경 방지 해야한다
    - 체크섬을 확장한 기술 사용
- 인증
    - 송신자, 수신자가 서로 상대방을 확인할 수 있어야 한다
- 운영 보안
    - 운영중인 네트워크망을 향한 공격을 방어를 해야한다

<br>
<br>

# 암호화
- 많은 시스템에선 두 방식을 혼합해서 사용한다

## 대칭키 암호화
- 하나의 키로 암호화 복호화를 모두 수행
- 암호화/복호화 처리 속도가 빠르다

## 공개키 암호화
- 공개키와 개인키(비밀키) 쌍이 존재
- 개인키로 암호화, 공개키로 복호화 또는 공개키로 암호화, 개인키로 복호화
- 예시
    - RSA

<br>
<br>


# 무결성과 인증
- 수신자가 메세지를 받으면 판단해야하는 사항
    - 송신자에게 온 메세지가 맞는가?
    - 메세지는 변경되지 않았나?

## 전자 서명: 메세지 무결성
- 방식
    - 송신자의 개인키는 공개/ 도난 되지 않았음을 가정합니다
    - 송신자는 메세지를 해시 함수를 이용해 고정 길이 값으로 해싱합니다
        - 메세지 자체를 암호화하는건 처리 속도가 좋지 않습니다
    - 송신자는 개인키로 해시값을 암호화 합니다
    - 송신자는 메세지와 함께 암호화값을 함께 전송합니다
    - 수신자는 송신자의 공개키를 이용해 암호화값을 복호화 합니다. 복호화값이랑 메세지를 비교에 메세지 변경을 확인합니다

## 종단점 인증
- 하나의 개체가 다른 개체에게 네트워크 상에서 인증하는 작업
- 프로토콜
    - ap 1.0
        - 메세지를 통한 인증
    - ap 2.0
        - ip address 를 통한 인증
    - ap 3.0
        - 비밀번호를 통한 인증
    - ap 3.1
        - 암호화된 비밀번호를 통한 인증
    - ap 4.0
        - nonce(nunmber used once)를 이용한 인증
- ap 4.0 방식
    - 그 이전 버전은 보안 취약점이 있다
    - 송신자는 수신자에게 통신 요청
    - 수신자는 nonce를 생성해 송신자에게 전송
    - 송신자는 자신의 비밀키를 이용해 nonce를 암호화
    - 송신자는 암호화값과 자신의 공개키를 수신자에게 전송
    - 수신자는 송신자의 공개키를 이용해 복호화, 복호화값이 자신이 만든 nonce임을 확인
    - 수신자는 일치시 자신에게 공개키를 공유한 송신자를 인식


## 인증 기관 CA
- Certificate Authority
- 디지털 인증서 제작 기관
- 본인만의 공개키 개인키가 존재
- 디지털 인증서
    - 송신자: 인증서를 받고 싶은 객체, 수신자: 인증 기관
    - 송신자의 공개키를 받아 인증 기관의 개인키로 암호화한 값
- 인증서가 나타내는 송신자의 공개키를 보증한다
- 모든 CA는 계층 형태로 조직을 이루며 하위 CA는 상위 CA로 부터 인증을 받습니다
- 공인 CA: 널리 신뢰받는 CA
    - VeriSign, DigCert
- 사설 CA


# 프로토콜
## SSL
- Secure Sockets Layer
- 통신 암호화 기능이 추가된 TCP 프로토콜
- 1990년대 Netscape가 개발
- 지금은 사용하지 않는다

## TLS
- Transport Layer Security
- SSL 후속 버전의 통신 암호화 프로토콜
- 현재 웹 보안 표준
### hand shake
- tcp 3 way handshake이후 클라이언트측에서 TLS handshake 시작 
- 클라이언트(송신자)는 자신이 지원하는 TLS Version, 지원하는 암호화 방식, 클라이언트 난수를 전송
- 서버는 사용할 TLS Version, 사용할 암호화 방식, 서버 난수, 자신의 디지털 인증서를 를 클라이언트에 응답
- 클라이언트는 인증기관에게 물어 인증서를 검증해 서버의 공개키를 알아냅니다, pre-master-secret를 생성해 서버의 공개키로 암호화 해 서버에 전송
- 클라이언트는 f(클라이언트 난수, 서버 난수, pre-master-secret) 을 이용해 master-secret을 생성, master-secret를 이용해 session key를 생성
- 서버는 pre-master-secret를 개인키로 복호화, f(클라이언트 난수, 서버 난수, pre-master-secret) 을 이용해 master-secret을 생성, master-secret를 이용해 session key를 생성
- 클라이언트와 서버는 동일한 session key를 가지게 되어 인증 절차 과정이 완료됨을 알리는 메세지를 주고 받는다 

## HTTPS
- HTTP + Secure
- HTTP 기반에 TLS을 사용해 통신 암호화

