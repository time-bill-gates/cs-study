JVM(Java Virtual Machine)은 자바 프로그램을 실행하기 위한 가상 머신으로, 자바 바이트코드를 플랫폼에 종속되지 않고 실행할 수 있도록 하는 핵심 컴포넌트입니다. 

## **JVM 주요 구성 요소**

![image](https://github.com/woowa-techcamp-2024/dev-log/assets/59289648/8d7aaac4-987b-47a2-b0a4-d70458689de3)


### **클래스 로더 시스템 (Class Loader Subsystem)**:
   - 자바 프로그램이 실행될 때, 필요한 클래스 파일(.class)을 동적으로 로드하고 연결하는 역할을 합니다.
   - 클래스 로더는 세 가지 기본 클래스로 구분됩니다:
     - **Bootstrap ClassLoader**: JVM의 기본 클래스 로더로, `rt.jar`에 포함된 표준 자바 라이브러리를 로드합니다.
     - **Extension ClassLoader**: 확장된 라이브러리(jar 파일)를 로드합니다.
     - **Application ClassLoader**: 사용자 애플리케이션에서 정의한 클래스들을 로드합니다.
   - 클래스 로더는 다음 세 가지 주요 작업을 수행합니다:
     1. **로딩(Loading)**: 클래스 파일을 로드하여 메서드 영역에 저장합니다.
     2. **링크(Linking)**
	     - verification: 파일이 적절히 포맷되었는지, 유효한 컴파일러에 의해 생성되었는지 확인한다.
	     - preparation: JVM은 메모리를 기본 값으로 초기화한 후, 클래스 변수들을 위한 메모리에 할당한다.
	     - resolution: symbolic references 를 direct references 로 바꾼다.
     3. **초기화(Initialization)**: 클래스의 `static` 변수와 `static` 블록을 초기화합니다.

### **메모리 영역 (Runtime Data Area)**:
   - JVM은 프로그램 실행 시 다양한 메모리 영역을 사용합니다. 이 메모리 영역은 크게 다음과 같이 나뉩니다:
     1. **메소드 영역(Method Area)**:
        - 모든 스레드가 공유하는 영역으로, 클래스 정보(클래스 이름, 메소드 및 필드, 상수 등)와 정적 변수, 상수 풀 등이 저장됩니다.
     2. **힙 영역(Heap Area)**:
        - 모든 객체와 배열이 동적으로 생성되는 공간입니다. 가비지 컬렉션이 관리하는 영역이며, 모든 스레드가 공유합니다.
     3. **스택 영역(Stack Area)**:
        - 각 스레드마다 하나씩 존재하는 영역으로, 메소드 호출 시 메소드의 지역 변수와 메소드 호출 정보(스택 프레임)가 저장됩니다.
     4. **PC 레지스터(Program Counter Register)**:
        - 각 스레드가 현재 실행 중인 JVM 명령어의 주소를 저장하는 레지스터입니다.
     5. **네이티브 메소드 스택(Native Method Stack)**:
        - 자바가 아닌 네이티브 메소드를 실행할 때 사용되는 스택입니다. 주로 C/C++로 작성된 네이티브 코드를 호출할 때 사용됩니다.

### **실행 엔진 (Execution Engine)**:
   - 자바 바이트코드를 실제 기계어로 변환하고 실행하는 엔진입니다. 실행 엔진은 다음과 같은 구성 요소로 이루어집니다:
     1. **인터프리터(Interpreter)**:
        - 자바 바이트코드를 한 줄씩 해석하여 실행합니다. 빠르게 시작할 수 있지만, 반복 실행 시 속도가 느려지는 단점이 있습니다.
     2. **JIT 컴파일러(Just-In-Time Compiler)**:
        - 인터프리터의 단점을 보완하기 위해, 자주 실행되는 바이트코드(핫스팟)를 기계어로 컴파일하여 캐시합니다. 이를 통해 프로그램의 성능을 향상시킵니다.
     3. **가비지 컬렉터(Garbage Collector)**:
        - JVM은 힙 메모리 내에서 더 이상 사용되지 않는 객체를 자동으로 관리하여 메모리를 효율적으로 사용하는 가비지 컬렉션을 수행합니다.

### **네이티브 인터페이스 (Java Native Interface, JNI)**:
   - 자바 코드가 네이티브 메소드(C/C++로 작성된 메소드)를 호출할 수 있도록 해주는 인터페이스입니다. 자바와 네이티브 코드 간의 상호작용을 가능하게 하여, 자바가 제공하지 않는 플랫폼 종속적인 기능에 접근할 수 있습니다.

### **네이티브 메소드 라이브러리 (Native Method Libraries)**:
   - 네이티브 코드로 작성된 라이브러리를 포함하는 영역입니다. 자바 프로그램이 JNI를 통해 호출하는 네이티브 메소드들이 이 영역에 포함된 라이브러리에서 실행됩니다.


## **자바 프로그램이 실행되는 과정**

### 1. **소스 코드 작성 및 컴파일**
   - 개발자는 자바 언어로 `.java` 파일을 작성합니다.
   - 자바 소스 파일은 사람이 읽을 수 있는 고수준의 언어로 작성되지만, 컴퓨터가 이해하기 위해서는 기계어로 변환될 필요가 있습니다.
   - 자바 컴파일러(`javac`)는 `.java` 파일을 **바이트코드**로 변환하여 `.class` 파일을 생성합니다.
   - 바이트코드는 JVM이 이해할 수 있는 중간 언어로, 플랫폼 독립적입니다.
   
     ```bash
     javac HelloWorld.java
     ```
   - 이 명령을 실행하면 `HelloWorld.class` 파일이 생성됩니다.

### 2. **클래스 로딩 (Class Loading)**
   - 자바 프로그램을 실행할 때, JVM의 **클래스 로더**는 필요한 클래스 파일들을 메서드 영역에 로드합니다.
   - JVM의 클래스 로더는 세 단계로 나뉩니다:
     1. **로딩 (Loading)**: `HelloWorld.class` 파일을 **Bootstrap ClassLoader** 또는 **Application ClassLoader**가 로드합니다.
     2. **링크 (Linking)**:
        - **검증(Verification)**: 클래스 파일 형식이 유효한지, 바이트코드가 올바른지 확인합니다. 자바는 강력한 보안성을 위해 클래스 파일이 JVM에서 안전하게 실행될 수 있는지 검증합니다.
        - **준비(Preparation)**: 클래스의 정적 필드(변수)가 기본 값으로 메모리에 할당됩니다. 예를 들어 `int`는 0, `boolean`은 `false`로 초기화됩니다.
        - **해결(Resolution)**: 모든 심볼릭 참조(변수나 메소드의 참조)가 실제 메모리 주소로 변환됩니다.
     3. **초기화 (Initialization)**:
        - 클래스의 `static` 블록과 정적 변수가 초기화됩니다. 예를 들어, 클래스의 `static` 변수가 명시적으로 값을 할당받으면 그 값으로 초기화됩니다.

### 3. **메모리 할당 (Memory Allocation)**
   - 클래스가 로드되면 JVM은 각 메모리 영역에 필요한 데이터를 할당합니다.
   - 자바 프로그램이 실행되면 JVM 내의 **메모리 영역**이 다음과 같이 사용됩니다:
     - **메소드 영역(Method Area)**: 클래스 구조 정보, 메소드의 바이트코드, 상수 풀, 정적 변수 등이 저장됩니다.
     - **힙 영역(Heap Area)**: `new` 키워드로 생성된 모든 객체가 저장됩니다.
     - **스택 영역(Stack Area)**: 메소드 호출 시 생성되는 지역 변수, 매개 변수, 리턴 값 등이 저장됩니다. 각 스레드마다 독립된 스택이 있습니다.
     - **PC 레지스터(Program Counter Register)**: 현재 실행 중인 JVM 명령어의 주소가 저장됩니다.
     - **네이티브 메소드 스택(Native Method Stack)**: 네이티브 메소드(C, C++로 작성된 메소드)가 호출될 때 사용됩니다.

### 4. **바이트코드 실행 (Execution of Bytecode)**
   - 클래스가 로드되고 메모리가 할당되면, **실행 엔진**이 바이트코드를 해석하고 실행합니다.
   - 실행 엔진은 두 가지 방식으로 바이트코드를 실행합니다:
     1. **인터프리터(Interpreter)**:
        - 자바 바이트코드를 한 줄씩 해석하여 기계어로 변환하고 실행합니다.
        - 초기 실행 속도는 빠르지만, 반복적으로 실행되는 코드는 속도가 느려질 수 있습니다.
     2. **JIT 컴파일러(Just-In-Time Compiler)**:
        - JVM은 실행 중에 자주 사용되는 바이트코드를 감지하고, JIT 컴파일러가 해당 코드를 **기계어로 컴파일**하여 캐시합니다.
        - 이 기계어 코드는 이후에 인터프리터 대신 직접 실행되므로 성능이 향상됩니다.
        - **JIT 컴파일**은 특정 메소드나 루프를 빠르게 실행하는 데 매우 효과적입니다.
   
   - JVM은 바이트코드를 최적화하여 성능을 높이는 다양한 기법을 사용합니다. JIT 컴파일러가 기계어로 컴파일할 때, 자주 호출되는 메소드나 코드 블록을 최적화합니다.

### 5. **가비지 컬렉션 (Garbage Collection)**
   - **가비지 컬렉터(Garbage Collector)**는 더 이상 참조되지 않는 객체를 감지하고, 그 객체가 차지하던 메모리를 회수하여 새로운 객체를 위한 공간을 확보합니다.
   - 가비지 컬렉션은 보통 두 단계로 이루어집니다:
     1. **마킹(Marking)**: 사용 중인 객체와 사용하지 않는 객체를 식별합니다.
     2. **스위핑(Sweeping)**: 사용되지 않는 객체를 메모리에서 제거하고 공간을 확보합니다.
   
   - JVM의 힙 영역은 **Young Generation**과 **Old Generation**으로 나뉘며, 가비지 컬렉션은 두 영역에서 다르게 작동합니다:
     - **Young Generation**: 새로 생성된 객체가 저장되며, **Minor GC**가 자주 발생합니다.
     - **Old Generation**: 오래된 객체가 저장되며, **Major GC**가 드물게 발생하지만 더 많은 메모리를 확보합니다.

### 6. **네이티브 메소드 실행 (Native Method Invocation)**
   - 자바 프로그램이 자바 외부의 네이티브 코드(C, C++ 등)를 실행해야 할 때는 **JNI (Java Native Interface)**를 통해 네이티브 메소드를 호출합니다.
   - 네이티브 메소드는 운영체제의 기능이나 하드웨어에 직접 접근할 때 유용하며, 자바에서 제공하지 않는 기능을 보완할 수 있습니다.

### 7. **프로그램 종료 (Termination)**
   - 자바 프로그램이 종료되면 JVM은 각종 리소스를 정리하고 할당된 메모리를 반환합니다.
   - 모든 스레드가 종료되고, 마지막으로 가비지 컬렉션이 실행된 후 JVM은 자체적으로 종료됩니다.
	   - 항상 가비지 컬렉션이 실행된다고 보장할 수는 없음

### 요약
1. **자바 소스 코드**를 작성한 후 컴파일러(`javac`)를 사용해 **바이트코드(.class 파일)** 로 컴파일.
2. **클래스 로더**가 JVM의 **메소드 영역**에 바이트코드를 로드.
3. **실행 엔진**이 바이트코드를 **인터프리터**나 **JIT 컴파일러**를 통해 실행.
4. **가비지 컬렉터**가 더 이상 사용되지 않는 객체를 힙에서 제거.
5. 자바 애플리케이션이 종료되면 JVM이 리소스를 정리하고 종료.


# References
- https://mygumi.tistory.com/115