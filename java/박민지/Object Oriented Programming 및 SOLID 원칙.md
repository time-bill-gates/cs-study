객체 지향 프로그래밍(Object-Oriented Programming, OOP)은 "객체"라는 개념을 기반으로 데이터를 속성(필드) 형태로, 그리고 그 데이터에 작용하는 코드를 메서드(함수) 형태로 정의하는 프로그래밍 패러다임입니다. 

OOP는 다음과 같은 이유로 도입되었습니다.
- **복잡한 소프트웨어 시스템을 더 쉽게 관리**하기 위해.
	- OOP는 **데이터(객체)와 관련된 기능을 하나로 묶어** 관리함으로써 복잡한 프로그램을 더 잘 관리할 수 있도록 해줍니다. 객체들은 각각 독립된 단위로 동작하고, 서로 상호작용하기 때문에 프로그램의 복잡성을 줄여줍니다.
- **코드 재사용성을 높이고** 중복 코드를 줄이기 위해.
	- OOP는 **상속과 다형성**을 통해 기존 클래스를 재사용하거나 확장할 수 있습니다. 즉, 기존의 클래스를 기반으로 새 클래스를 만들거나, 공통된 인터페이스를 사용해 서로 다른 객체들을 일관되게 사용할 수 있습니다. 이로 인해 **코드의 재사용성이 크게 향상**되었습니다.
- **유지보수성과 확장성**을 확보하기 위해.
	- OOP는 **캡슐화**와 **추상화**를 통해 객체의 내부 구현을 외부에서 숨기고, 인터페이스를 통해 기능을 제공하기 때문에 코드 수정 시 다른 부분에 영향을 주지 않고 독립적으로 변경할 수 있습니다. 또한, **확장이 용이**해서 새로운 기능을 추가할 때 기존 코드를 크게 수정할 필요가 없습니다.
- **현실 세계의 객체를 자연스럽게 모델링**할 수 있도록 하기 위해.
	- 현실 세계의 사물이나 개념을 객체로 표현하고, 그 객체 간의 관계와 상호작용을 코드로 구현함으로써 **자연스러운 설계**가 가능합니다.
- **모듈화된 개발**을 통해 대규모 프로젝트를 효율적으로 관리하기 위해.
	- 각 객체는 독립적으로 설계되고 개발될 수 있으며, 다른 객체들과는 최소한의 인터페이스만을 공유합니다. 이를 통해 **프로그램의 모듈성이 증가**하고, 각 모듈을 별도로 개발, 테스트, 유지보수할 수 있습니다.

OOP는 다음과 같은 네 가지 주요 원칙을 강조합니다:

### 1. **캡슐화 (Encapsulation)**
   - **정의**: 캡슐화는 데이터(속성)와 그 데이터를 다루는 메서드(함수)를 하나의 단위로 묶어 외부로부터 데이터를 보호하는 개념입니다. 외부에서는 메서드를 통해서만 객체 내부 데이터에 접근할 수 있게 합니다.
   - **목적**: 데이터 보호 및 무분별한 접근 방지
   - **예시**
	   - 자바에서 `private` 접근 제어자를 사용해 데이터를 숨기고, `public` 메서드(`getter`, `setter`)를 통해 데이터에 접근합니다.

### 2. **추상화 (Abstraction)**
   - **정의**: 추상화는 객체의 복잡한 내부 구현을 숨기고, 필요한 부분만 외부에 노출시키는 개념입니다. 
   - **목적**: 복잡성을 줄이고, 중요한 정보만을 노출하여 사용자가 객체를 쉽게 사용할 수 있게 함.
   - **예시**
	   - 자바의 추상 클래스, 인터페이스를 통해 특정 구현 세부 사항을 감추고 인터페이스만 제공하여 상호작용할 수 있습니다.

### 3. **상속 (Inheritance)**
   - **정의**: 상속은 새로운 클래스가 기존 클래스(부모 클래스)의 속성과 메서드를 물려받아 사용할 수 있는 개념입니다. 이를 통해 코드 재사용성이 높아지고, 계층 구조를 쉽게 표현할 수 있습니다.
   - **목적**
	- **코드 재사용**: 중복된 코드를 줄이고, 부모 클래스에서 정의된 속성과 메서드를 자식 클래스에서 그대로 사용할 수 있습니다.
	- **유지보수 용이**: 부모 클래스에서 기능을 변경하면, 이를 상속받는 모든 자식 클래스에 자동으로 적용되므로 유지보수가 쉬워집니다.
	- **계층 구조 표현**: 상속을 통해 클래스를 계층적으로 구성할 수 있으며, 상위 클래스에서 공통된 기능을 정의하고, 하위 클래스에서 구체화할 수 있습니다.
   - **예시**
	   - 자바에서 `class Dog`는 `class Animal`로부터 상속받아, 부모 클래스의 속성과 메서드를 사용할 수 있으며, 필요하면 추가하거나 수정할 수 있습니다.

### 4. **다형성 (Polymorphism)**
   - **정의**: 다형성은 같은 타입의 객체가 다른 방식으로 동작할 수 있도록 하는 개념입니다. 
   - **목적**
	- **동일한 인터페이스로 다양한 객체 처리**: 다형성을 통해 동일한 인터페이스를 통해 서로 다른 클래스의 객체들을 다룰 수 있습니다. 이는 코드의 유연성과 확장성을 높여 줍니다.
	- **유지보수성 향상**: 다형성을 사용하면 새로운 클래스나 기능을 추가할 때 기존 코드를 수정하지 않고도 기능을 확장할 수 있습니다.
	- **동적 메서드 호출**: 런타임에 객체의 실제 타입에 맞는 메서드가 호출되기 때문에 코드의 유연성이 높아집니다.
   - **예시**
	   - 자바에서 메서드 오버라이딩을 통해 자식 클래스가 부모 클래스의 메서드를 재정의할 수 있습니다.
	   - 매개변수가 다른 경우, 같은 이름의 메서드를 정의할 수 있음
	   - 상위 클래스 타입의 참조변수로 하위 클래스의 객체를 참조할 수 있는 것
   - 타입을 캡슐화하는 역할

### OOP의 장점:
- **모듈성**: 각각의 객체가 독립적인 단위로 데이터와 메서드를 가집니다.
- **재사용성**: 상속을 통해 기존 코드를 재사용할 수 있습니다.
- **유지보수성**: 캡슐화와 추상화를 통해 코드 유지보수가 용이합니다.
- **유연성**: 다형성과 동적 메서드 바인딩을 통해 다양한 객체 처리에 유연성을 제공합니다.


### SOLID 원칙
객체 지향 프로그래밍(OOP)에서 **유지보수성**, **확장성**, **재사용성**을 높이기 위한 다섯 가지 설계 원칙입니다.

#### 1. **단일 책임 원칙 (Single Responsibility Principle, SRP)**
   - **정의**: **클래스는 하나의 책임만 가져야 하며, 하나의 액터(actor)나 기능에만 책임**을 져야 한다는 원칙입니다.
   - **목적**: 한 클래스가 여러 책임을 지게 되면, 그 책임 중 하나가 변경될 때 클래스 전체가 수정되어야 할 가능성이 커지므로, 이를 방지하고 **유지보수를 쉽게** 하기 위함입니다.
   - **예시**:
     ```java
     class Report {
         public void generateReport() { /* 보고서 생성 코드 */ }
         public void printReport() { /* 보고서 출력 코드 */ }
     }
     ```
     위 예시는 `Report` 클래스가 **보고서 생성과 출력**이라는 두 가지 책임을 지고 있습니다. 이를 SRP에 맞게 분리하면:
     ```java
     class ReportGenerator {
         public void generateReport() { /* 보고서 생성 코드 */ }
     }

     class ReportPrinter {
         public void printReport() { /* 보고서 출력 코드 */ }
     }
     ```

#### 2. **개방-폐쇄 원칙 (Open/Closed Principle, OCP)**
   - **정의**: **소프트웨어 요소(클래스, 모듈, 함수 등)는 확장에는 열려 있어야 하지만, 수정에는 닫혀 있어야 한다**는 원칙입니다. 즉, 새로운 기능을 추가할 때 기존 코드를 수정하지 않고 확장할 수 있도록 설계해야 합니다.
   - **목적**: 기존 코드를 변경하지 않고도 기능을 확장함으로써 **코드의 안정성**을 보장하고, **변경에 따른 부작용을 방지**하기 위함입니다.
   - **예시**:
     ```java
     class Payment {
         public void processPayment(String paymentType) {
             if (paymentType.equals("credit")) {
                 // 신용카드 결제
             } else if (paymentType.equals("paypal")) {
                 // 페이팔 결제
             }
         }
     }
     ```
     OCP를 적용하여 결제 수단을 확장할 때 기존 코드를 수정하지 않도록 `Payment` 클래스를 확장 가능하게 변경:
     ```java
     interface PaymentMethod {
         void processPayment();
     }

     class CreditCardPayment implements PaymentMethod {
         public void processPayment() { /* 신용카드 결제 코드 */ }
     }

     class PayPalPayment implements PaymentMethod {
         public void processPayment() { /* 페이팔 결제 코드 */ }
     }
     ```

#### 3. **리스코프 치환 원칙 (Liskov Substitution Principle, LSP)**
   - **정의**: **자식 클래스는 언제나 부모 클래스를 대체할 수 있어야 한다**는 원칙입니다. 자식 클래스가 부모 클래스의 동작을 깨뜨리거나 예상하지 못한 동작을 하지 않도록 해야 합니다.
   - **목적**: 상속 관계에서 자식 클래스가 부모 클래스의 기능을 유지하면서 확장하도록 함으로써 **일관된 동작**을 보장합니다.
   - **예시**:
     ```java
     class Bird {
         public void fly() { /* 날 수 있는 새 */ }
     }

     class Ostrich extends Bird {
         @Override
         public void fly() { throw new UnsupportedOperationException("타조는 날 수 없습니다."); }
     }
     ```
     위 예시는 LSP 위반입니다. `Bird` 클래스의 `fly()` 메서드를 상속받은 `Ostrich` 클래스는 `fly()` 기능을 제공하지 못하므로 부모 클래스를 대체할 수 없습니다. 이를 개선하려면 설계를 수정해야 합니다.

#### 4. **인터페이스 분리 원칙 (Interface Segregation Principle, ISP)**
   - **정의**: **클라이언트는 자신이 사용하지 않는 메서드에 의존하지 않도록, 인터페이스는 최소한의 기능만 제공해야 한다**는 원칙입니다. 즉, 인터페이스는 **작고 구체적**이어야 하며, **여러 목적을 위한 인터페이스를 분리**해야 합니다.
   - **목적**: 불필요한 메서드 의존성을 줄이고, **인터페이스를 사용하는 클래스가 필요하지 않은 메서드에 의존하지 않도록** 하기 위함입니다.
   - **예시**:
     ```java
     interface Worker {
         void work();
         void eat();
     }
     class Developer implements Worker {
         public void work() { /* 개발 작업 */ }
         public void eat() { /* 개발자도 먹음 */ }
     }
     class Robot implements Worker {
         public void work() { /* 로봇 작업 */ }
         public void eat() { /* 로봇은 먹지 않음 */ } // 불필요한 메서드
     }
     ```
     위 예시는 `Robot` 클래스가 `eat()` 메서드에 의존하게 되어 불필요한 책임을 가지게 됩니다. ISP를 적용하면:
     ```java
     interface Workable {
         void work();
     }
     interface Eatable {
         void eat();
     }

     class Developer implements Workable, Eatable {
         public void work() { /* 개발 작업 */ }
         public void eat() { /* 개발자도 먹음 */ }
     }

     class Robot implements Workable {
         public void work() { /* 로봇 작업 */ }
     }
     ```

#### 5. **의존성 역전 원칙 (Dependency Inversion Principle, DIP)**
   - **정의**: **상위 모듈은 하위 모듈에 의존해서는 안 되고, 둘 다 추상화된 인터페이스에 의존해야 한다**는 원칙입니다. 또한, **구체적인 구현이 아닌 추상화에 의존해야 한다**는 개념입니다.
   - **목적**: 상위 모듈이 하위 모듈에 의존하지 않도록 하여 **유연성과 확장성을 높이고**, **변경에 대한 영향을 최소화**하기 위함입니다.
   - **예시**:
     ```java
     class Light {
         public void turnOn() { /* 전구 켜기 */ }
     }

     class Switch {
         private Light light;
         public Switch(Light light) {
             this.light = light;
         }
         public void operate() {
             light.turnOn();
         }
     }
     ```
     위 예시는 `Switch` 클래스가 `Light`에 직접 의존하고 있어 DIP를 위반합니다. DIP를 적용하면:
     ```java
     interface Switchable {
         void turnOn();
     }

     class Light implements Switchable {
         public void turnOn() { /* 전구 켜기 */ }
     }

     class Switch {
         private Switchable device;
         public Switch(Switchable device) {
             this.device = device;
         }
         public void operate() {
             device.turnOn();
         }
     }
     ```


| 원칙                    | 정의                                         | 목적                                    |
| --------------------- | ------------------------------------------ | ------------------------------------- |
| **SRP (단일 책임 원칙)**    | 클래스는 하나의 책임만 가져야 한다                        | 유지보수성 향상 및 코드 수정의 영향을 최소화             |
| **OCP (개방-폐쇄 원칙)**    | 소프트웨어는 확장에는 열려 있어야 하고, 수정에는 닫혀 있어야 한다      | 코드 수정 없이 기능 확장을 용이하게 함                |
| **LSP (리스코프 치환 원칙)**  | 자식 클래스는 부모 클래스를 대체할 수 있어야 한다               | 상속 관계에서 일관성을 유지하며, 예상치 못한 동작을 방지함     |
| **ISP (인터페이스 분리 원칙)** | 클라이언트는 자신이 사용하지 않는 메서드에 의존하지 않아야 한다        | 인터페이스를 구체적이고 작은 단위로 분리하여 불필요한 의존성을 줄임 |
| **DIP (의존성 역전 원칙)**   | 상위 모듈은 하위 모듈에 의존하지 않고, 추상화된 인터페이스에 의존해야 한다 | 상위 모듈과 하위 모듈 간의 결합도를 낮추고 유연성을 높임      |


# References
- [https://www.codestates.com/blog/content/객체-지향-프로그래밍-특징](https://www.codestates.com/blog/content/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95)