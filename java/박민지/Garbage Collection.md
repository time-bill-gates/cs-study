**Garbage Collection(GC)** 은 JVM이 **메모리를 자동으로 관리**하는 메커니즘으로, 더 이상 사용되지 않는 객체들을 감지하고 그들이 차지하고 있는 메모리를 해제하여 새로운 객체를 위한 공간을 확보하는 과정입니다. 

## **Garbage Collection의 주요 개념**

1. **자동 메모리 관리**:
   - 자바는 객체를 명시적으로 해제하는 방법을 제공하지 않으며, 메모리 할당은 개발자가 `new` 키워드를 통해 객체를 생성할 때 이루어집니다.
   - **가비지 컬렉션**은 더 이상 참조되지 않는 객체를 자동으로 메모리에서 해제하여 시스템 메모리가 부족하지 않도록 관리합니다.
   
2. **힙 메모리 관리**:
   - JVM은 힙 메모리를 **Young Generation**과 **Old Generation**으로 나눠 관리합니다. 가비지 컬렉션은 이 두 세대를 중심으로 이루어집니다.
     - **Young Generation**: 새롭게 생성된 객체들이 저장되며, 자주 가비지 컬렉션이 발생하는 영역입니다.
     - **Old Generation**: Young Generation에서 오래 살아남은 객체들이 이동하는 영역으로, 가비지 컬렉션이 덜 자주 발생하지만 더 많은 메모리를 차지할 수 있습니다.

3. **Stop-the-World (STW)**:
   - 가비지 컬렉션이 실행되는 동안 JVM은 애플리케이션의 모든 스레드를 일시 중지합니다. 이를 **Stop-the-World(STW)** 라고 부르며, 이 시간이 길어질 경우 애플리케이션의 성능에 영향을 미칠 수 있습니다.
   - **필요성**
	   - 객체가 서로 참조하는 상태가 변동 중이라면, JVM이 참조 체인을 정확하게 추적할 수 없게 됩니다. 따라서, 모든 스레드를 중단시켜 객체 간 참조 관계를 고정시킵니다.
	   - 만약 가비지 컬렉션 중에 애플리케이션이 동작하고 있다면, **동시성 문제**가 발생할 수 있습니다.
		   - 한 스레드가 객체를 참조하는 중에 다른 스레드가 그 객체를 삭제하거나, 객체의 참조 상태를 변경할 수 있습니다. 이와 같은 상황은 데이터 손실이나 잘못된 객체 삭제로 이어질 수 있습니다.
	   - 일부 가비지 컬렉션 알고리즘은 가비지 컬렉션 후에 메모리 압축(Compaction)을 수행합니다. 이 과정에서 살아남은 객체들이 메모리 상에서 재배치되는데, 객체가 메모리 내에서 이동되는 동안 애플리케이션이 실행 중이라면, 잘못된 메모리 참조가 발생할 수 있습니다.
	   - 만약 스레드가 계속 동작 중인 상태에서 GC 작업을 하려면, 추가적인 복잡한 동기화 작업이 필요하게 되어 GC 성능이 저하될 수 있습니다. 
	
## **가비지 컬렉션의 동작 원리**

가비지 컬렉션은 보통 **Mark and Sweep** 알고리즘을 기반으로 작동합니다. 이 알고리즘은 크게 세 단계로 이루어집니다:

1. **Marking(마킹)**: 
   - 사용 중인 객체와 그렇지 않은 객체를 식별합니다. 모든 객체를 검사하며, 현재 참조 중인 객체(사용 중인 객체)에 마킹을 합니다.

2. **Sweeping(스위핑)**:
   - 참조되지 않는 객체(마킹되지 않은 객체)를 메모리에서 제거하여 공간을 확보합니다.

3. **Compaction(압축)**:
   - 객체가 제거되고 남은 공간을 정리하여 **단편화(fragmentation)** 문제를 해결합니다. 이 과정을 통해 메모리를 연속된 공간으로 재배치합니다.

## **가비지 컬렉션 방식**

가비지 컬렉션은 크게 두 가지 주요 방식으로 나뉩니다: **Minor GC**와 **Major GC (Full GC)**.

1. **Minor GC**:
   - **Young Generation**에서 발생하며, Eden 영역이 가득 차면 실행됩니다.
   - 새로 생성된 객체들이 주로 Young Generation의 Eden 영역에 저장되며, Minor GC가 발생하면 Eden 영역에서 살아남은 객체들이 Survivor 영역으로 이동합니다.
   - Minor GC는 상대적으로 빈번하게 발생하며, Young Generation에서 불필요한 객체를 빠르게 제거합니다.

2. **Major GC (Full GC)**:
   - **Old Generation**에서 발생하는 가비지 컬렉션입니다.
   - Old Generation에 있는 객체는 오랫동안 참조되고 있기 때문에 가비지 컬렉션이 덜 자주 발생합니다. 하지만 Major GC는 전체 힙을 검사하므로 더 많은 시간을 소모하여, STW 시간이 길어질 수 있습니다.
   - Major GC는 Young Generation과 Old Generation을 모두 대상으로 가비지 컬렉션을 수행하기 때문에 **Full GC**라고도 부릅니다.

## **가비지 컬렉션 알고리즘**

JVM은 다양한 가비지 컬렉션 알고리즘을 제공합니다. 각각의 알고리즘은 애플리케이션의 성능 특성에 맞춰 최적화할 수 있습니다.

#### Serial GC
- **Mark-Sweep-Compaction**: Old Generation에서 살아 있는 객체를 마킹한 뒤, 사용되지 않는 객체를 정리하고 남은 객체를 연속적으로 재배치합니다.
- **적합한 환경**: 메모리와 CPU 자원이 적은 시스템에서 성능이 비교적 안정적입니다.
- **STW**: 가비지 컬렉션 동안 전체 애플리케이션이 멈추며, 단일 스레드로 처리하기 때문에 장시간 멈출 수 있습니다.

#### Parallel GC
- **병렬 처리**: Serial GC와 같은 알고리즘을 사용하나, 여러 스레드가 동시에 GC 작업을 수행하므로, **스루풋(Throughput)**이 향상됩니다.
- **적합한 환경**: 멀티코어 시스템에서 유리하며, CPU 코어가 많은 서버에서 성능 향상 효과가 큽니다.

#### CMS GC (Concurrent Mark Sweep)
- **Low Latency**: 짧은 STW 시간을 제공하기 위해 **동시 가비지 컬렉션**을 수행합니다.
- **동작 과정**:
    1. **Initial Mark**: 살아 있는 객체 중 루트 객체에서 가장 가까운 참조만 빠르게 식별(짧은 STW).
    2. **Concurrent Mark**: 나머지 객체들을 추적하며, 다른 스레드가 실행 중에도 마킹 진행.
    3. **Remark**: Concurrent Mark 중 변경된 객체들을 다시 확인(짧은 STW).
    4. **Concurrent Sweep**: 살아 있지 않은 객체를 제거.
- **단점**: **Compaction** 단계를 포함하지 않기 때문에 **메모리 단편화** 문제 발생. 장기 실행 시 힙 공간이 단편화되면 성능 저하 가능.

#### G1 GC
- **Region-based**: 힙을 작은 **Region** 단위로 나누어 관리하고, GC가 필요한 영역부터 먼저 수집하는 방식입니다.
- **Mixed GC**: 마킹 이후 일부 Old Generation까지 포함해 가비지 컬렉션을 실행
- **STW 최소화**: 애플리케이션의 성능에 미치는 영향을 최소화하기 위해 자주 사용되지 않는 영역부터 수집하여 STW 시간을 줄입니다.
- **SATB(Snapshot-At-The-Beginning):** 마킹 사이클의 시작 시점에 힙의 **살아 있는 객체 상태**를 스냅샷으로 캡처
	- 애플리케이션이 계속 실행되면서 객체 할당과 참조가 변경될 때도 안전하게 마킹할 수 있어 STW를 줄일 수 있음
- **적합한 환경**: CMS GC보다 효율적인 성능을 제공하며, 대규모 애플리케이션 및 저지연 시스템에 적합합니다.

#### ZGC
- **참조 색칠(Reference Coloring)**: 64비트 참조의 가상 메모리 비트인 42비트를 실제 객체 주소에 할당하고, 42~45번째 비트의 공간을 colored pointer로 사용해 GC 처리 시 활용
- **Marking 및 Relocating**: 동시 마킹을 통해 살아 있는 객체를 추적하고, 객체를 새 페이지로 재배치하여 힙을 최적화.
- **로드 배리어**: 객체 참조 시 마킹 및 리맵핑을 처리해 최신 객체 주소를 유지.
- **적합한 환경**: 저지연과 대규모 힙이 필요한 애플리케이션에 적합.

## **가비지 컬렉션 최적화 및 튜닝**

가비지 컬렉션은 자동으로 메모리를 관리하지만, 성능 최적화를 위해 GC 설정을 튜닝할 수 있습니다. JVM 옵션을 통해 가비지 컬렉터를 선택하고, 힙 크기 등을 조정하여 GC 성능을 최적화할 수 있습니다. 

- `-XX:+UseG1GC`: G1 가비지 컬렉터를 사용하도록 JVM에 지시.
- `-Xms`: 초기 힙 크기 설정.
- `-Xmx`: 최대 힙 크기 설정.

# References
- https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html
- https://www.oracle.com/technical-resources/articles/java/g1gc.html
- https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html
- https://d2.naver.com/helloworld/0128759