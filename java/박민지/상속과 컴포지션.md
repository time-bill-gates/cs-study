**상속(Inheritance)** 과 **컴포지션(Composition)** 은 객체 지향 프로그래밍에서 **코드 재사용성**과 **구조 설계**를 위해 사용하는 두 가지 중요한 기법입니다. 각각의 개념과 차이점을 설명해드리겠습니다.

### 1. **상속 (Inheritance)**
   - **정의**: 상속은 **기존 클래스(부모 클래스)** 의 속성과 메서드를 **새로운 클래스(자식 클래스)** 가 물려받는 기법입니다. 자식 클래스는 부모 클래스의 기능을 그대로 사용할 수 있으며, 필요에 따라 **기존 기능을 재정의(오버라이딩)** 하거나 **새로운 기능을 추가**할 수 있습니다.
   - **특징**:
     - **"is-a" 관계**: 상속은 부모와 자식 클래스 간에 **"is-a"** 관계를 형성합니다. 예를 들어, `Dog` 클래스가 `Animal` 클래스를 상속받으면, "개는 동물이다"라고 말할 수 있습니다.
     - **코드 재사용**: 부모 클래스의 코드(메서드, 속성)를 자식 클래스에서 재사용할 수 있습니다.
     - **다형성**: 상속을 통해 다형성(Polymorphism)을 구현할 수 있습니다. 부모 클래스를 참조하여 자식 클래스 객체를 사용할 수 있어 코드의 유연성이 높아집니다.
   
   - **예시**:
     ```java
     class Animal {
         public void eat() {
             System.out.println("This animal eats food.");
         }
     }

     class Dog extends Animal {
         public void bark() {
             System.out.println("Woof!");
         }
     }

     public class Main {
         public static void main(String[] args) {
             Dog dog = new Dog();
             dog.eat();  // 부모 클래스 메서드 사용
             dog.bark(); // 자식 클래스 메서드 사용
         }
     }
     ```

   - **상속의 장점**:
     - 부모 클래스에서 작성한 코드의 **재사용**.
     - 다형성을 통해 **유연한 객체 사용** 가능.
     - 간단한 계층 구조로 **논리적인 관계 표현**이 용이.

   - **상속의 단점**:
     - **강한 결합**: 자식 클래스가 부모 클래스에 강하게 의존하게 되어, 부모 클래스가 변경되면 자식 클래스도 영향을 받을 수 있습니다.
     - **유연성 부족**: 상속을 통해 기능을 확장하는 방식은 구조가 고정되어 있어서, 재사용과 수정이 어려울 수 있습니다.
   
---

### 2. **컴포지션 (Composition)**
   - **정의**: 컴포지션은 **클래스가 다른 클래스의 객체를 포함(멤버 변수로 사용)** 하여 기능을 재사용하는 기법입니다. 즉, 한 클래스가 다른 클래스의 **객체를 소유**하고, 이를 통해 기능을 제공하는 방식입니다.
   - **특징**:
     - **"has-a" 관계**: 컴포지션은 클래스 간에 **"has-a"** 관계를 형성합니다. 예를 들어, `Car` 클래스는 `Engine` 클래스를 포함할 수 있으며, "자동차는 엔진을 가지고 있다"라는 관계로 표현할 수 있습니다.
     - **유연성**: 컴포지션은 객체 간의 관계를 느슨하게 만들어, 코드 변경에 더 유연하게 대처할 수 있습니다. 객체를 교체하거나 추가하는 방식으로 기능을 확장할 수 있습니다.
   
   - **예시**:
     ```java
     class Engine {
         public void start() {
             System.out.println("Engine started.");
         }
     }

     class Car {
         private Engine engine; // Engine 객체를 포함

         public Car() {
             this.engine = new Engine();
         }

         public void startCar() {
             engine.start(); // Engine 객체의 메서드를 사용
             System.out.println("Car is running.");
         }
     }

     public class Main {
         public static void main(String[] args) {
             Car car = new Car();
             car.startCar(); // Car가 Engine 객체를 통해 기능을 제공
         }
     }
     ```

   - **컴포지션의 장점**:
     - **유연성 증가**: 객체 간의 결합도가 낮아서, 클래스 간의 관계를 쉽게 변경하거나 확장할 수 있습니다.
     - **단일 책임 원칙(SRP) 준수**: 각 클래스가 하나의 책임에 집중하고, 다른 객체와의 협력을 통해 기능을 구현할 수 있습니다.
     - **재사용성**: 객체 조합을 통해 기능을 확장할 수 있으며, **재사용성이 높아집니다**.

   - **컴포지션의 단점**:
     - **설계의 복잡성**: 상속에 비해 설계가 더 복잡해질 수 있으며, 객체 간의 관계를 설정하는 데 더 많은 코드가 필요할 수 있습니다.

---

### 상속과 컴포지션 비교

| **특징**        | **상속(Inheritance)**          | **컴포지션(Composition)**                |
| ------------- | ---------------------------- | ------------------------------------ |
| **관계**        | "is-a" 관계 (예: 개는 동물이다)       | "has-a" 관계 (예: 자동차는 엔진을 가지고 있다)      |
| **코드 재사용**    | 부모 클래스의 기능을 물려받아 재사용         | 객체를 포함해 기능을 재사용                      |
| **결합도**       | 부모-자식 간 **강한 결합**            | 클래스 간 **느슨한 결합**                     |
| **유연성**       | 구조가 고정적이고 유연성이 낮음            | 객체를 조합하여 유연하게 확장 가능                  |
| **다형성**       | 상속을 통해 다형성 구현 가능             | 포함된 객체의 메서드를 호출하여 기능 구현              |
| **설계 복잡도**    | 상대적으로 간단한 설계                 | 객체 간의 관계 설정이 다소 복잡할 수 있음             |
| **변경에 대한 영향** | 부모 클래스의 변경이 자식 클래스에 큰 영향을 미침 | 포함된 객체만 교체하거나 수정할 수 있어 변경에 대한 영향이 적음 |

---

### 언제 상속을 사용하고 언제 컴포지션을 사용할까?

- **상속을 사용해야 할 때**:
  - 클래스 간에 **명확한 "is-a" 관계**가 있을 때.
  - 다형성을 통해 **유사한 동작을 여러 클래스에서 공유**할 필요가 있을 때.
  - 부모 클래스의 기능을 자식 클래스가 **확장하거나 수정**해야 할 때.

- **컴포지션을 사용해야 할 때**:
  - **유연한 설계**가 필요하고, 기능을 여러 클래스에서 독립적으로 재사용해야 할 때.
  - 클래스 간에 **강한 결합**을 피하고 **느슨한 결합**을 유지하고 싶을 때.
  - 기능을 **동적으로 변경하거나 확장**해야 할 때.

결론적으로, 상속은 간단한 계층 구조에서 유용하지만, **강한 결합**과 **유연성 부족**으로 인해 복잡한 시스템에서 문제가 될 수 있습니다. 반면, 컴포지션은 **유연하고 확장 가능한** 설계를 제공하며, **느슨한 결합** 덕분에 유지보수와 변경이 쉬운 구조를 만들어 줍니다. **OOP에서 일반적으로 컴포지션을 더 선호**하는 이유도 이러한 장점 때문입니다.