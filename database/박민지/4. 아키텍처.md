---
banner: img/Screenshot 2023-11-21 at 1.59.06 AM.png
---
## 개요
mysql 서버는 ==mysql 엔진과 mysql 스토리지 엔진으로 구성==
- **mysql 엔진:** 요청된 SQL문장을 분석하거나 최적화 작업 수행
- **mysql 스토리지 엔진:** 디스크 스토리지에 저장하거나 데이터를 읽기 작업 수행
	- 핸들러 API를 만족하는 다른 구현체를 mysql 서버에 추가하여 사용 가능
	- mysql 서버 디폴트는 InnoDB 스토리지 엔진

## mysql 엔진 아키텍처
### mysql 전체 구조
![[Screenshot 2023-11-21 at 2.21.10 AM.png]]
 대부분 프로그래밍 언어가 접근할 수 있는 방법을 지원
 - 기본 C API + JDBC, ODBC, .NET 표준 드라이버 제공
	 - 드라이버를 이용하여 모든 언어로 mysql 서버에서 쿼리를 사용할 수 있음

**mysql 엔진** 
- ==요청된 SQL문장을 분석하거나 최적화 작업 수행==
- **구성요소)**
	- 클라이언트 접속 및 쿼리 요청을 처리하는 커넥션 핸들러
	- SQL 파서 및 전처리기
	- 쿼리의 최적화된 실행을 위한 옵티마이저
- **참고)**
	- 표준 SQL([[참고#ASNI SQL]]) 문법을 지원하므로 표준 문법에 따라 작성된 쿼리는 타 DBMS와 호환 가능

**스토리지 엔진**
- 실제 ==데이터를 디스크 스토리지에 저장하거나 데이터를 읽어오는 역할==
- mysql 서버에서 mysql 엔진은 하나이나 여러 스토리지 엔진을 사용할 수 있음
	- 다음과 같이 테이블이 사용할 스토리지 엔진을 지정할 수 있음
	  ![[Screenshot 2023-11-21 at 2.14.48 AM.png]]
- 성능 향상을 위해 키 캐시나 InnoDB 버퍼 풀과 같은 기능을 내장하고 있음

**핸들러 API**
- ==mysql 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽기 위한 스토리지 엔진의 쓰기/읽기 작업에 사용되는 API==
- 다음과 같이 얼마나 많은 데이터 작업이 있었는지 확인할 수 있음
  ![[Screenshot 2023-11-21 at 2.20.25 AM.png]]

### mysql 스레딩 구조
![[Screenshot 2023-11-21 at 2.20.56 AM.png]]
> [!NOTE]
> mysql 커뮤니티 에디션에서 사용되는 스레드 모델로, 엔터프라이즈 에디션 등에서는 ==스레드 풀 모델==을 사용할 수 있다.
> 

mysql 서버는 프로세스가 아닌 ==스레드 기반으로 동작==
- ==Foreground 스레드와 Background 스레드==로 구분
	- 다음과 같이 mysql 서버에서 실행 중인 스레드 목록을 확인할 수 있음
	  ![[Screenshot 2023-11-21 at 2.23.20 AM.png]]

**Foreground 스레드**
- 주로 ==각 클라이언트가 요청하는 쿼리 문장을 처리하는 역할==
	- mysql 서버에 접속한 클라이언트 수만큼 존재
- 작업을 마쳐 커넥션을 종료하면 해당 커넥션을 담당하는 스레드는 스레드 캐시로 되돌아감
	- 이미 스레드 캐시에 일정 개수 이상 대기 중인 스레드가 있는 경우, 스레드 캐시에 넣지 않고 스레드를 종료시켜 일정 개수 스레드를 유지
		- `thread_cache_size` 시스템 변수를 통해 설정 가능
- 데이터를 mysql 데이터 버퍼나 캐시에서 가져오며, 버퍼나 캐시에 없는 경우 직접 디스크나 인덱스 파일에서 데이터를 읽어와 작업을 처리
- myisam 테이블은 디스크 쓰기 작업까지 foreground 스레드가 처리
- ==InnoDB 테이블은 **데이터 버퍼나 캐시까지만 foreground 스레드가 처리**하고, **버퍼에서 디스크까지 기록하는 작업은 백그라운드 스레드**가 처리==

**Background 스레드**
- myisam은 거의 해당하지 않으나, InnoDB는 여러 가지 작업을 백그라운드 스레드로 처리
	- Insert Buffer를 병합하는 스레드
	- 로그를 디스크로 기록하는 스레드
	- InnoDB 버퍼 풀의 데이터를 데스크에 기록하는 스레드
	- 디스크 데이터를 버퍼로 읽어오는 스레드
	- 잠금이나 데드락을 모니터링하는 스레드
- mysql 5.5 이상부터 데이터 쓰기/읽기 스레드를 2개 이상 지정 가능
	- `innodb_write_io_threads`와 `innodb_read_io_threads` 시스템 변수로 스레드 개수 설정 가능
	- 데이터 읽기 스레드는 클라이언트 스레드에서 처리하므로 많이 설정할 필요 없음
	- 데이터 쓰기 스레드는 많은 작업을 백그라운드로 처리하므로 커스텀하는 것이 좋음
		- 일반 내장 디스크는 2~4
- ==InnoDB에서 데이터 쓰기 작업은 성능을 위해 버퍼링하여 일괄 처리==
	- myisam은 사용자 스레드가 쓰기 작업까지 함께 처리하므로 쓰기 버퍼링 기능을 사용할 수 없음


### 메모리 할당 및 사용 구조
![[Screenshot 2023-11-21 at 2.44.20 AM.png]]
mysql의 메모리 공간은 ==글로벌 메모리 영역과 로컬 메모리 영역==으로 구분

**글로벌 메모리 영역**
- **대표적인 영역)**
	- 테이블 캐시
	- InnoDB 버퍼 풀
	- InnoDB 어댑티브 해시 인덱스
	- InnoDB 리두 로그 버퍼
- mysql 서버가 시작되며 운영체제가 할당
	- 한번에 할당해주거나, 예약해둔 뒤 필요할 때 조금씩 할당해주는 경우도 있음
- 클라이언트 스레드 수와 무관하게 하나의 메모리 공간만 할당되며, 필요에 따라 여러 개를 할당 받을 수 있음
	- 할당된 영역이 여러 개더라도 모든 스레드에 의해 공유됨

**로컬 메모리 영역(세션 메모리 영역)**
-  mysql 서버 상에 존재하는 ==클라이언트 스레드가 쿼리를 처리할 때 사용하는 메모리 영역==
- **대표적인 영역)**
	- 정렬 버퍼 
	- 조인 버퍼
	- 바이너리 로그 캐시
	- 네트워크 버퍼
- ==각 클라이언트 스레드별로 독립적으로 할당되며, 절대 공유되어 사용되지 않음==
	- 각 쿼리의 용도별로 필요할 때만 공간이 할당되고 필요하지 않은 경우 아예 할당하지 않는 경우도 있음
		- 대표적으로 정렬 버퍼, 조인 버퍼
	- 커넥션 시간 동안 할당되는 공간도 있고, 쿼리 실행 순간에만 할당했다 다시 해제하는 공간(정렬/조인 버퍼)도 있음
- 가능성은 희박하나 로컬 메모리 영역 크기 때문에 mysql 서버 메모리가 부족할 수 있으므로 적절히 커스텀할 필요가 있음

### 플러그인 스토리지 엔진 모델
![[Screenshot 2023-11-21 at 3.06.31 AM.png]]
==여러 부가적인 기능을 제공하는 플러그인을 추가할 수== 있음
- ex) 스토리지 엔진, 전문 검색 엔진을 위한 검색어 파서, 비밀번호 검증, 커넥션 제어 등
- mysql 서버의 기능을 커스텀하게 확장하기 쉬움
![[Screenshot 2023-11-21 at 3.52.30 AM.png]]
- mysql 작업 대부분이 mysql 엔진에서 처리되므로 스토리지 엔진을 만든다 하더라도 mysql의 일부분을 작성하는 것
- `GROUPY BY`, `ORDER BY` 등 복잡한 처리는 스토리지 엔진이 아닌 mysql 엔진 영역의 쿼리 실행기에서 처리됨

다음과 같이 mysql에서 지원하는 스토리지 엔진을 확인 가능
- ![[Screenshot 2023-11-21 at 2.47.22 PM.png]]
- mysql 서버에 포함되지 않은 스토리지 엔진을 사용하려면 스토리지 엔진을 플러그인에 추가 후 mysql 서버를 다시 빌드해야 함
- 다음과 같이 mysql의 플러그인 확인 가능
  ![[Screenshot 2023-11-21 at 2.49.49 PM.png]]
> [!NOTE]
> 자세한 사항은 mysql 매뉴얼 참고

### 컴포넌트
mysql 8.0부터 ==플러그인 아키텍처를 대체하기 위한 컴포넌트 아키텍처==가 지원됨
- mysql 5.7까지 플러그인 형태이던 비밀번호 검증 기능이 8.0부터 컴포넌트로 개선됨

**플러그인 아키텍처의 단점**
- 플러그인은 mysql 서버와 상호작용할 수 있고, 플러그인끼리 통신 불가
- mysql 서버 변수, 함수를 직접 호출하므로 안전하지 않음
- 플러그인은 상호 의존 관계를 설정할 수 없어 초기화가 어려움

> [!NOTE]
> 자세한 사항은 mysql 매뉴얼 참고

### 쿼리 실행 구조
![[Screenshot 2023-11-21 at 2.56.17 PM.png]]
**쿼리 파서**
- ==사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리해 트리 형태 구조인 파서 트리로 만들어내는 작업==
- 쿼리 문장의 기본 문법 오류는 이 과정에서 발견됨

**전처리기**
- ==파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인하는 작업==
- 각 토큰을 테이블 이름, 칼럼 이름, 내장 함수와 같은 개체에 매핑해 객체의 존재 여부와 접근 권한 등을 확인
- 실제 존재하지 않거나, 권한상 사용할 수 없는 개체의 토큰은 이 과정에서 발견됨

**옵티마이저**
- ==요청된 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리하는 방법을 결정하는 작업==

**실행 엔진**
- ==쿼리 실행 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 작업==
- ex) 옵티마이저가 `GROUP BY`를 처리하기 위해 임시 테이블을 사용하기로 결정한 경우
	1. 실행 엔진이 임시 테이블을 만들라고 핸들러에게 요청
	2. 실행 엔진은 `WHERE` 절에 일치하는 레코드를 읽어오라고 핸들러에게 요청
	3. 읽어온 레코드들을 1번에서 준비한 임시 테이블로 저장하라고 핸들러에게 요청
	4. 테이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어 오라고 핸들러에게 요청
	5. 실행 엔진은 읽어온 데이터를 사용자 혹은 다른 모듈에 넘김

**핸들러(스토리지 엔진)**
- ==mysql 서버 가장 밑단에서 mysql 실행 엔진의 요청에 따라 데이터를 디스크로 쓰거나 디스크에서 읽는 작업==
	- 결국 스토리지 엔진을 의미

### 복제
> [!NOTE]
> 16장에서 살펴볼 예정

### 쿼리 캐시
- SQL의 실행 결과를 ==메모리에 캐시해두고 동일 SQL 쿼리가 실행되면 테이블을 읽지 않고 즉시 결과를 반환==하므로 매우 빠른 성능을 보임
- 다만, 테이블 데이터가 변경될 경우 ==변경된 테이블과 관련된 캐시는 invalidate 처리가 필요하여 동시 처리 성능 저하==
	- 데이터 쓰기 작업 거의 없이 읽기만 하는 서비스는 흔치 않으므로 큰 도움이 되지 않음
- mysql 서버 성능 개선 과정에서 쿼리 캐시가 많은 버그의 원인이 되기도 했음
- 이에 ==8.0부터 쿼리 캐시는 mysql 서버 기능에서 완전히 제거==됨

### 스레드 풀
> [!NOTE]
> mysql 엔터프라이즈 에디션에 포함된 스레드 풀 대신 **Percona Server에서 제공하는 스레드 풀 기능**을 살펴봄
> 
- Percona Server 스레드풀은 내장이 아닌 플러그인 형태로 작동되게 구현되어있으므로 스레드풀 라이브러리를 플러그인으로 추가해야 함
- 내부적으로 사용자 요청을 처리하는 스레드 개수를 줄여 ==동시 처리되는 요청이 많더라도 mysql 서버의 cpu가 제한된 수의 스레드 처리에만 집중하도록 해 서버의 자원 소모를 줄이는 것이 목적==
	- CPU의 프로세서 친화도를 높이고 불필요한 컨텍스트 스위치를 줄여 오버헤드를 낮출 수 있음
	- 다만 실제 서비스에서 눈에 띄는 성능 향상을 보여준 경우는 드묾
	- **스레드 스케줄링 과정에서 CPU 시간을 충분히 확보하지 못한다면 쿼리 처리가 더 느려질 수도** 있음
- percona server 스레드풀은 기본적으로 CPU 코어 개수만큼 스레드 그룹 생성
	- `thread_pool_size` 시스템 변수로 조정 가능
	- 일반적으로 cpu 코어 개수와 맞추는 것이 CPU 프로세서 친화도를 높이는 데 좋음
- mysql 서버가 처리해야 할 요청이 생기면 스레드 풀로 처리를 위임하는데, **스레드 풀이 처리 중인 작업이 있다면 `thread_pool_oversubscribe` 만큼 더 받아들여 처리**
	- `thread_pool_oversubscribe` 값이 너무 크다면 스케줄링해야 할 스레드가 더 많아져 비효율적으로 작동할 수 있음
- 스레드 그룹의 모든 스레드가 일을 처리하고 있다면 스레드 풀은 해당 스레드 그룹에 새로운 작업 스레드를 추가할지, 기존 작업 스레드가 처리를 완료할 때까지 기다릴지 여부를 판단해야 함
	- 스레드 풀의 타이머 스레드는 주기적으로 스레드 그룹 상태를 체크하여 `thread_pool_stall_limit`에 정의된 밀리초만큼 작업 스레드가 지금 처리 중인 작업을 끝내지 못하면 새로운 스레드를 생성해 스레드 그룹에 추가
		- 이 때 스레드 풀의 전체 스레드 개수는 `thread_pool_max_threads`보다 클 수 없음
	- 응답 시간에 아주 민감하다면 `thread_pool_stall_limit`를 낮은 값으로 설정
		- 다만 0에 가까운 값으로 설정하는 것은 스레드 풀을 사용하지 않는 편이 나을 수도 있음

Percona Server 스레드 풀 플러그인은 **선순위 큐와 후순위 큐를 이용해 특정 트랜잭션이나 쿼리를 우선적으로 처리할 수 있는** 기능 제공
- 먼저 시작된 트랜잭션을 빨리 처리한다면 잠금이 빨리 해제되어 잠금 경합을 낮춰 전체적인 처리 성능을 향상시킬 수 있음
![[Screenshot 2023-11-21 at 3.23.52 PM.png]]

### 트랜잭션 지원 메타데이터
**메타데이터(데이터 딕셔너리):** 데이터베이스 서버의 테이블의 구조 정보와 스토어드 프로그램 등의 정보
- mysql 서버는 5.7까지 테이블 구조를 FRM 파일에 저장하고 일부 스토어드 프로그램 또한 파일 기반으로 관리
	- **파일 기반 메타데이터는 생성/변경 작업이 트랜잭션을 지원하지 않아 테이블 생성/변경 도중 mysql 서버가 비정상적으로 종료되면 일관되지 않은 상태로 남는 문제**가 존재
- ==mysql 서버는 8.0부터 메타데이터를 InnoDB 테이블에 저장하도록 개선==
	- ==mysql 서버가 작동하는 데 기본적으로 필요한 테이블들인 시스템 테이블 또한 모두 InnoDB를 사용하도록 개선==
	- 스키마 변경 작업 중간 mysql 서버가 비정상적으로 종료되더라도 원자성을 지킬 수 있음
	- 시스템 테이블, 메타데이터를 모두 mysql DB에 저장하고 있음 
	- **mysql DB는 `mysql.ibd`라는 이름의 테이블스페이스에 저장하고 있으므로 주의 필요**
> [!NOTE]
> 사용자가 임의로 수정하지 못하도록 테이블 목록 조회 시 메타데이터 테이블은 보이지 않으나 존재하며,
> `information_scehma DB`의 `TABLES`와 `COLUMNS` 같은 뷰를 통해 조회할 수 있음
> 
> `mysql.tables`  테이블에 관해 조회해보면 **테이블이 없음 에러가 아닌 접근 거절 에러가 발생**
> ![[Screenshot 2023-11-21 at 3.34.14 PM.png]]
- InnoDB 외 스토리지 엔진을 사용하는 테이블들은 SDI([[참고#Serialized Dictionary Information]]) 파일을 사용
	- 기존의 `*.FRM` 파일과 동일한 역할
	- `ibd2sdi` 유틸리티를 이용해 InnoDB 테이블 스페이스에서 스키마 정보 추출 가능

## InnoDB 스토리지 엔진 아키텍처
![[Screenshot 2023-11-21 at 3.10.31 AM.png]]
- InnoDB는 mysql에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 ==레코드 기반 잠금 제공==
	- 따라서 높은 동시성 처리 가능, 안정적, 고성능
### 프라이머리 키에 의한 클러스터링
- ==InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장==됨
	- 프라이머리 키 값의 순서대로 디스크에 저장됨
	- 세컨더리 인덱스는 레코드 주소 대신 프라이머리 키값을 논리적인 주소로 사용
	- ==클러스터링되어 있으므로 프라이머리 키 기반 스캔은 성능이 좋음==
		- 쿼리 실행 계획에서 다른 보조 인덱스보다 프라이머리 키가 선택될 확률이 높음
- ==myisam은 클러스터링 키를 지원하지 않음==
	- 따라서 프라이머리 키는 유니크 제약을 가진 세컨더리 인덱스와 같음
	- 프라이머리 키를 포함한 모든 인덱스는 물리적인 레코드의 주소값([[참고#ROWID]])을 가짐

### 외래 키 지원
-  InnoDB가 아닌 myisam이나 memory 테이블에서는 사용할 수 없음
- 외래 키는 부모/자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하고, 변경 시 반드시 부모 테이블이나 자식 테이블에 데이터가 있는 체크하므로 ==잠금이 여러 테이블로 전파되어 데드락이 발생할 때가 많으므로== 개발 시 주의 필요
- `foreign_key_checks`를 비활성화하여 외래 키 관계에 대한 체크 작업을 일시적으로 멈출 수 있음
	- 레코드 적재, 삭제 등 부가적인 체크가 필요 없어 훨씬 빠르게 처리 가능
	- 다만, 비활성화했다고 해서 부모-자식 테이블 간 관계가 깨진 상태로 유지해도 되는 것은 아님
	- `foreign_key_checks` 적용 범위는 `GLOBAL`, `SESSION` 있고, 디폴트는 `SESSION`

### MVCC(Multi Version Concurrency Control)
- ==한 레코드에 대해 여러 개 버전이 동시에 관리되어 필요에 따라 다른 버전이 사용되는 것==
	- 레코드 레벨 트랜잭션을 지원하는 DBMS가 제공하는 기능
- ==잠금을 사용하지 않는 일관된 읽기를 제공하는 것이 주 목적==
- InnoDB는 ==언두 로그를 이용해 MVCC를 구현==
	- ex) mysql 서버에서 격리 수준에 따른 InnoDB를 사용하는 테이블 데이터 변경 처리 예시
		1. 테이블에 한 record를 insert
		2. InnoDB 버퍼 풀과 디스크에 해당 record가 존재하게 됨
		3. 해당 record를 update
		4. 아직 커밋하지 않았을 때, InnoDB 버퍼풀은 새로운 값으로 업데이트, 디스크 파일은 업데이트되었을 수도, 되지 않았을 수도 있으며, 기존값은 언두 영역에 존재하게 됨
			1. 이 때, 해당 레코드 조회 시 `READ_UNCOMMITTED`인 경우, **InnoDB 버퍼 풀이 현재 가지고 있는 데이터를 반환**
			2. 이 때, 해당 레코드 조회 시 `READ_COMMITTED` 이상인 경우, **언두 영역의 데이터를 반환**
			3. commit 실행 시 현재 상태를 영구적인 상태로 만듦
				- 커밋한다고 언두 영역의 백업 데이터가 바로 삭제되는 것은 아님
				- **해당 영역 데이터를 필요로 하는 트랜잭션이 없을 때 비로소 삭제됨**
			4. rollback 실행 시 언두 영역의 데이터를 InnoDB 버퍼풀로 복구하고 언두 영역 내용을 삭제
	- 트랜잭션이 길어지면 언두 영역 데이터 공간이 커짐

### 잠금 없는 일관된 읽기 (Non-Locking Consistent Read)
InnoDB는 ==MVCC, 언두 로그를 활용하여 `SERIALIZABLE` 미만 격리 수준에서 잠금을 걸지 않고 읽기 작업을 수행==
- **일관된 읽기를 위해 언두 로그를 삭제하지 못하고 계속 유지해야** 하므로, 오랜 시간 활성 상태인 트랜잭션이 있다면 mysql 서버가 느려지거나 문제가 발생할 수 있음
- **트랜잭션이 시작됐다면 가능한 한 빨리 롤백이나 커밋을 통해 트랜잭션 완료하는 것을 권장**

### 자동 데드락 감지
- InnoDB는 내부적으로 데드락이 발생하지 않았는지 체크하기 위해 ==잠금 대기 목록을 그래프(wait-for-list) 형태로 관리==
- InnoDB는 ==데드락 감지 스레드가 존재==
	- 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사, 교착 상태에 빠진 트랜잭션들을 찾아 그 중 하나를 강제 종료
	- 롤백 시 부하가 적으므로 일반적으로 ==언두 로그 양이 더 적은 트랜잭션이 강제 종료==됨
- InnoDB는 mysql 엔진에서 관리하는 테이블 잠금은 볼 수 없어 데드락 감지가 불확실할 수 있음
	- `innodb_table_locks` 시스템 변수를 활성화하여 테이블 잠금을 감지하는 걸 권장
- 동시 처리 스레드가 매우 많아지거나 트랜잭션이 가지는 잠금 수가 많아지면 데드락 감지 스레드가 느려짐
	- 데드락 감지 스레드는 잠금 목록을 검사해야 하므로, ==잠금 상태가 변경되지 않도록 잠금 목록이 저장된 테이블에 잠금을 걸고 데드락 스레드를 탐지==
	- 따라서 쿼리 처리 중인 스레드는 더 작업하지 못하고 대기하며 서비스에 악영향을 끼칠 수 있음
	- 이를 해결하기 위해 ==`innodb_deadlock_detect`를 off로 설정하여 데드락 감지 스레드를 동작하지 않게== 할 수 있음
		- 다만 데드락을 감지할 수 없으므로 데드락 발생 시 트랜잭션이 무한 대기하게 됨
		- ==`innodb_lock_wait_timeout` 시스템 변수를 활성화하여 지정된 시간 동안 잠금을 얻지 못하면 요청이 실패하도록 타임아웃을 걸 수== 있음

### 자동화된 장애 복구
- InnoDB는 mysql 서버가 시작될 때 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된 데이터 페이지 등에 대한 복구 작업이 자동으로 진행
- 디스크, 하드웨어 이슈로 InnoDB가 자동 복구를 못할 수 있음
	- 이후 자동 복구를 멈추고 시작되던 mysql 서버가 종료됨
	- 이 경우, `innodb_force_recovery`를 설정해 mysql 서버를 재시작해야 함
		- `innodb_force_recovery` 값에 따라 데이터 파일/로그 파일 손상 여부 검사 과정을 선별적으로 진행
			- 0이 아닌 복구 모드에서 SELECT 이외 INSERT/UPDATE/DELETE 쿼리 수행 불가
		- ![[Screenshot 2023-11-21 at 4.12.51 PM.png]]
		  ![[Screenshot 2023-11-21 at 4.13.10 PM.png]]
	- 위와 같이 진행했음에도 **mysql 서버가 시작되지 않는다면 백업을 이용해 다시 구축해야** 함
		- 마지막 백업으로 데이터베이스를 새로 구축하고, 바이너리 로그를 이용해 최대한 장애 시점까지 데이터를 복구할 수 있음
		- 마지막 풀 백업 시점부터 바이너리 로그가 있다면, InnoDB 복구보다 풀 백업과 바이너리 로그로 복구하는 편이 데이터 손실이 적을 수도 있음

### InnoDB 버퍼 풀
- ==디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해두는 공간==
- ==쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 하는 버퍼 역할==
	- 데이터 변경 쿼리는 디스크의 아무 곳에 위치한 데이터를 변경시키므로, 랜덤한 디스크 작업 횟수를 줄일 수 있음

**버퍼 풀 크기 설정**
- ==운영체제와 각 클라이언트 스레드가 사용할 메모리를 충분히 고려해 설정==해야 함
	- 클라이언트 세션에서 테이블의 레코드를 읽고 쓸 때 버퍼로 사용되는 레코드 버퍼는 커넥션이 많고, 사용하는 테이블도 많다면 상당한 양의 메모리 공간이 필요함
		- 레코드 버퍼 공간은 별도 설정이 불가능하고 전체 커넥션 개수와 각 커넥션에서 읽고 쓰는 테이블 개수에 따라 동적으로 결정되므로 정확히 메모리 공간 크기를 계산할 수 없음
	- **5.7부터 버퍼 풀 크기를 동적으로 조절할 수 있게 개선**됨
		- 작은 값으로 설정하여 상황을 봐 가며 증가시키는 방법이 최적
		- 처음으로 mysql 서버를 준비한다면
			- 운영체제 전체 메모리의 50% 정도를 버퍼 풀로 설정하고 조금씩 올려가며 최적점을 찾는 것을 권장
			- 전체 메모리가 50GB 이상이라면 15~30을 제외한 나머지를 버퍼풀 메모리로 사용하는 것을 권장
- `innodb_buffer_pool_size`로 크기 설정 가능
	- 내부적 청크 크기인 128MB 단위로 동적 확장 가능
	- 변수 변경 시 부하가 생길 수 있으므로 mysql 서버가 한가한 시점에 진행하는 것을 권장
		- 특히 크기를 줄이는 작업은 서비스 영향도가 매우 큼
- ==전체 버퍼 풀 관리 잠금으로 인해 내부 잠금 경합을 많이 유발해왔으나, 버퍼 풀을 여러 개로 쪼개어 관리할 수 있게 개선==됨
	- `innodb_buffer_pool_instances` 이용하여 버퍼 풀 개수 설정 가능
		- 기본적으로 8개이나 전체 버퍼 풀 메모리 공간이 1GB 미만이라면 1개만 생성됨
		- 버퍼풀 메모리 공간이 40GB 이하라면 8개, 더 크다면 한 인스턴스당 5GB 정도로 설정하는 것을 권장

**버퍼 풀 구조**
- ==페이지 크기 조각으로 쪼개어 InnoDB가 데이터를 필요로 할 때 해당 데이터 페이지를 읽어 각 조각에 저장==
	- 페이지 크기는 `innodb_page_size`로 설정 가능
- ==페이지 크기 조각 관리를 위해 LRU 리스트, Flush 리스트, Free 리스트 자료구조 관리==
	- **Free 리스트:** ==버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지 목록 관리==
		- 사용자 쿼리가 새롭게 디스크 데이터 페이지를 읽어와야 하는 경우 사용됨
	- **LRU 리스트:** ==디스크에서 한 번 읽어온 페이지를 오랜 시간 버퍼풀에 유지해서 디스크 읽기를 최소화==하는 목적
		- ![[Screenshot 2023-11-21 at 4.33.19 PM.png]]
		- 엄밀히 말해 **LRU(Old 서브리스트)와 MRU(New 서브리스트)가 결합된 형태**
		- ex) InnoDB가 데이터를 찾는 과정
			- ![[Screenshot 2023-11-21 at 4.37.19 PM.png]]

	- **Flush 리스트:** ==디스크로 동기화되지 않은 데이터를 가진 데이터 페이지의 변경 시점 기준 페이지 목록 관리==
		- 데이터가 변경되었다면 InnoDB는 변경 내용을 리두 로그와 버퍼 풀의 데이터 페이지에도 반영
			- 따라서 리두 로그의 각 엔트리는 특정 데이터 페이지와 연결됨
			- 다만 리두 로그가 디스크로 기록됐다고 해서 데이터 페이지가 디스크로 기록됐다는 것을 보장하지 않고, 반대의 경우도 마찬가지이므로 InnoDB는 체크포인트를 발생시켜 디스크의 리두 로그와 데이터 페이지 상태를 동기화
		- **체크포인트:** mysql 서버가 시작될 때 InnoDB가 리두 로그의 어느 부분부터 복구를 실행해야 할지 판단하는 기준점을 만드는 역할

**버퍼풀과 리두 로그**
![[Screenshot 2023-11-21 at 4.45.07 PM.png]]
- InnoDB 버퍼 풀에는 **디스크에서 읽은 상태인 클린 페이지**와 **변경된 데이터를 가진 더티 페이지**가 존재
	- 더티 페이지는 언젠가 디스크로 기록되어야 함
	- 리두 로그는 1개 이상 고정 크기 파일을 연결하여 순환 고리처럼 사용
	- 데이터 변경이 계속 발생하면 리두 로그 파일에 기록된 로그 엔트리는 새로운 로그 엔트리로 덮어쓰임
		- 따라서, 전체 리두 파일에서 재사용 가능한 공간과 당장 재사용 불가능한 공간 관리해야 하는데,
			- 재사용 불가능한 공간을 활성 리두 로그라 함 (그림의 화살표)
	- 리두 로그 파일 공간은 순환되어 재사용되지만 매번 기록될 때마다 로그 포지션은 계속 증가한 값을 갖게 됨
		- 이를 LSN(Log Sequence Number)라 함
		- InnoDB는 주기적으로 체크포인트 이벤트를 발생시켜 리두 로그, 버퍼 풀의 더티 페이지를 디스크로 동기화
			- 이렇게 발생한 최근 체크 포인트 지점의 LSN이 활성 리두 로그 공간의 시작점이 됨
			- 가장 최근 체크포인트의 LSN과 마지막 리두 로그 엔트리의 LSN 차이를 체크포인트 에이지라고 함
				- 체크포인트 에이지는 활성 리두 로그 공간의 크기를 말함
- **예시1)** 버퍼 풀 100GB, 리두 로그 파일 100MB
	- 체크포인트 에이지도 100MB
	- 평균 리두 로그 엔트리가 4KB, 데이터 페이지 크기가 16KB라면 
		- 100MB / 4KB X 16KB = 400MB 정도 더티 페이지만 버퍼풀에 보관 가능
	- 이 경우, 버퍼 풀은 매우 크나 쓰기 버퍼링 효과는 거의 없음
- **예시2)** 버퍼 풀 100MB, 리두 로그 파일 100GB
	- 위와 동일한 계산으로 400GB 더티 페이지를 가질 수 있음
	- 다만 버퍼 풀 크기가 100MB이므로 더티 페이지 크기는 100MB 이하
	- 버퍼 풀에 더티 페이지 비율이 너무 높은 상태에서 갑자기 버퍼 풀이 필요해지면 InnoDB는 매우 많은 더티 페이지를 한번에 기록해야 하므로 급작스러운 디스크 쓰기가 발생한 가능성이 높음
- 버퍼 풀의 크기가 100GB 이하에서는 리두 로그 파일 전체 크기를 대략 5~10GB로 선택, 필요할 때마다 늘려가며 최적값 탐색

**버퍼 풀 플러시**
- 5.6까지는 더티 페이지 플러시 기능이 부드럽게 처리되지 않았으나, 8.0에서는 기존과 같은 디스크 쓰기 폭증 현상은 거의 발생하지 않음
- InnoDB는 버퍼 풀에서 디스크로 기록되지 않은 더티 페이지들을 성능 상 악영향 없이 디스크에 동기화하기 위해 2개 플러시 기능을 백그라운드로 실행
	- **Flush 리스트 플러시:** 플러시 리스트에서 오래 전에 변경된 데이터 페이지 순서대로 디스크에 동기화
		- `innodb_page_cleaners`: 더티 페이지를 디스크로 동기화하는 클리너 스레드 개수 설정 가능
			- 한 버퍼 풀 인스턴스에 하나씩 존재(권장) 혹은 여러 버퍼 풀 인스턴스마다 하나씩 존재
		- `innodb_max_dirty_pages_pct`: 버퍼 풀 - 더티 페이지 비율 조정 가능
			- 더티 페이지는 전체 버퍼 풀이 가진 페이지의 90%까지 가질 수 있음
		- `innodb_io_capacity`: 더티 페이지 쓰기를 실행하는 기준값 설정 가능
			- 디스크로 기록되는 양보다 더티 페이지 발생 양이 더 크다면 디스크 쓰기 폭발 현상 발생 가능
			- 이 경우 `innodb_max_dirty_pages_pct_lwm`을 설정하여 일정 수준 이상 더티 페이지 발생 시 조금씩 디스크에 기록하게 할 수 있음
				- 기본값 10%
		- `innodb_io_capacity_max`: 디스크가 최대 성능을 발휘할 때 어느 정도의 디스크가 읽고 쓰기 가능한지 설정 가능
			- **참고)** 내부 최적화 알고리즘에 기반해 디스크 작업 횟수를 계산하므로 설정된 값의 디스크 작업을 보장하지 않음
			- 서버 트래픽을 봐가며 설정하는 것은 상당히 번거로우므로 `innodb_adaptive_flushing`을 통해 알고리즘을 사용하여 리두 로그 증가 속도를 분석하여 적절한 수준의 더티 페이지가 버퍼 풀에 유지될 수 있도록 디스크 쓰기를 실행
				- 더티 페이지 양이 `innodb_max_dirty_pages_pct_lwm` 값을 넘어간다면 어댑티브 플러시 알고리즘 동작
		- `innodb_flush_neighbors`: 더티 페이지를 디스크에 기록 시 디스크에서 근접한 페이지 중 더티 페이지가 있다면 함께 묶어 디스크로 기록하게 해주는 기능 설정 가능
			- HDD의 경우 활성화해주는 것이 좋음
	- **LRU 리스트 플러시:** 사용 빈도가 낮은 데이터 페이지들을 제거해 새로운 페이지를 읽을 공간을 만드는 것
		- `innodb_lru_scan_depth`: LRU 리스트 끝부분부터 스캔할 페이지 개수
			- 스캔을 진행하며 더티 페이지는 디스크에 동기화, 클린 페이지는 Free 리스트로 페이지를 옮김
			- 버퍼 풀 한 인스턴스마다 `innodb_lru_scan_depth`만큼 스캔

**버퍼 풀 상태 백업 및 복구**
- **워밍업:** 디스크 데이터가 버퍼 풀에 적재돼 있는 상태
	- 버퍼 풀이 잘 워밍업되어있다면 그렇지 않은 경우보다 몇십배 좋은 쿼리 처리 속도를 가짐
	- 5.5 버전에서는 mysql을 셧다운했다 다시 시작하는 경우, 강제 워밍업을 위해 주요 테이블/인덱스를 풀 스캔하고 시작
	- 5.6부터는 버퍼 풀 덤프/적재 기능이 도입됨
		- `innodb_buffer_pool_dump_now`: 현재 innoDB 버퍼 풀 상태 백업 가능
			- mysql 재시작 시 해당 시스템 변수를 이용해 백업된 버퍼 풀 상태 복구 가능
		- 백업은 데이터 디렉터리에 `ib_buffer_pool`이름의 파일로 생성
			- 버퍼 풀의 LRU 리스트에서 적재된 데이터 페이지 메타 정보만 저장하므로 몇십 MB 이하이나,
			- 실제 버퍼풀 복구 과정은 각 디스크에서 값을 읽어와야 하므로 상당한 시간이 걸릴 수 있음
		- `innodb_buffer_pool_load_abort`: 버퍼 풀 복구 실행 중인 상태에서 활성화하여 버퍼 풀 복구 멈출 수 있음
		- 버퍼 풀 백업 복구 자동화를 위해 `innodb_buffer_pool_dump_at_shutdown` , `innodb_buffer_pool_load_at_startup`을 mysql 설정 파일에 넣는 것을 권장

**버퍼 풀 적재 내용 확인**
- 5.6부터 `information_schema`의 `innodb_buffer_page`테이블로 버퍼 풀 메모리에 어떤 테이블의 페이지들이 적재되어있는지 확인 가능
	- 다만 버퍼 풀이 큰 경우, 테이블 조회가 상당한 부하를 일으켜 서비스 쿼리가 느려지는 문제가 있어 운영 중 확인이 거의 불가능했음
- 8.0에서는 `information_schema`에 `innodb_cached_indexed` 테이블이 추가되어 테이블 인덱스별로 데이터 페이지가 얼마나 버퍼 풀에 적재돼 있는지 확인 가능

### Double Write Buffer
- 리두 로그 공간의 낭비를 막기 위해 변경된 내용만 기록하는데, InnoDB가 더티 페이지를 디스크 파일로 플러시할 때 하드웨어 오작동 혹은 시스템 비정상 종료로 일부만 기록되는 문제가 발생하면 해당 페이지 내용은 복구할 수 없을 수 있음.
	- 이를 partial-page, torn-page라고 함
![[Screenshot 2023-11-21 at 5.22.42 PM.png]]
- 위 문제를 막기 위해 Double-Write 기법을 사용
	- 더티 페이지를 모두 한 번의 디스크 쓰기로 DoubleWrite 버퍼에 기록
	- 이후 각 더티 페이지를 디스크에 기록
	- 만약 데이터 파일 쓰기가 중간에 실패한 경우, 
		- InnoDB 재시작 시 DoubleWrite 버퍼 내용과 데이터 파일 페이지들을 모두 비교해 다른 내용을 담고 있는 페이지가 있는 경우, DoubleWrite 버퍼 내용을 데이터 파일 페이지로 복사
	- `innodb_doublewrite`로 사용 여부 설정 가능
		- HDD의 경우 부담되지 않으나, SSD의 경우 부담스러울 수 있음
			- SSD는 nand flash를 써서 메모리에 읽고 쓰는 행위 자체가 수명을 깎아먹는 행위이므로 부담이 큼
		- 다만 데이터 무결성이 매우 중요하다면 활성하는 것을 권장
		- 리두 로그 동기화 설정(`innodb_flush_log_at_trx_commit`)이 1이 아닌 값이라면 DoubleWrite도 비활성화하는 것을 권장

### 언두 로그
- InnoDB는 트랜잭션과 격리 수준을 보장하기 위해 DML로 변경 이전 버전의 데이터를 별도로 백업한 데이터
	- **트랜잭션 보장**
		- 롤백 수행 시 언두 로그에 백업해둔 이전 버전 데이터를 이용해 복구
	- **격리 수준 보장**
		- 잠금 없는 일관된 읽기 제공
- 다만 관리 비용도 많이 필요
- 5.5 이전에서는 한 번 증가한 언두 로그 공간이 다시 줄어들지 않았음
	- 100GB 테이블을 삭제하면 언두 로그 공간이 100GB가 됨
	- 트랜잭션이 오랜 시간 실행될 때도 언두 로그 양은 급격히 증가할 수 있음
	- 변경된 레코드를 조회하는 쿼리가 많이 실행될 경우 언두 로그를 스캔해야 하므로 쿼리 성능이 전반적으로 떨어질 수 있음
- ==5.7, 8.0에서 언두 로그를 돌아가면서 순차적으로 사용해 디스크 공간을 줄일 수 있고, 필요한 시점에 사용 공간을 자동으로 줄여줄 수 있도록 개선==됨
	- 여전히 장시간 활성 상태인 트랜잭션은 성능상 좋지 않으므로, 평상 시 언두 로그 레코드 건수를 확인해 급증 여부를 모니터링하는 것을 권장

**언두 테이블 스페이스 관리**
- 언두 테이블 스페이스: 언두 로그가 저장되는 공간
- 5.6 이전에서는 언두 로그가 모두 시스템 테이블스페이스(ibdata.ibd)에 저장됨
	- mysql 서버가 초기화될 때 언두 로그가 생성되므로 확장 한계가 존재했음
- 5.6에서 `innodb_undo_tablespaces`를 설정하여 별도 언두 로그 파일을 사용할 수 있게 개선됨
- 8.0에서 언두 로그는 항상 외부 별도 로그 파일에 기록되도록 개선됨
	- `CREATE UNDO TABLESPACE`, `DROP TABLESPACE` 명령으로 새로운 언두 테이블스페이스를 동적 추가/삭제 가능
![[Screenshot 2023-11-21 at 5.39.12 PM.png]]
- 한 언두 테이블 스페이스는 1개 이상 128개 이상 롤백 세그먼트를 가짐
- 롤백 세그먼트는 1개 이상 언두 슬롯을 가짐
	- InnoDB 페이지 크기 / 16byte 만큼 언두 슬롯을 가짐
	- 한 트랜잭션이 필요로 하는 언두 슬롯 개수는 트랜잭션이 실행하는 DML 특성에 따라 최대 4개까지 사용
		- 일반적으로 트랜잭션이 임시 테이블을 사용하지 않으므로 한 트랜잭션은 대략 2개 정도 언두 슬롯을 필요로 한다고 가정하면, 최대 동시 처리 가능한 트랜잭션 개수는 다음과 같음
		  ![[Screenshot 2023-11-21 at 5.41.36 PM.png]]
	- **언두 로그 슬롯이 부족하면 트랜잭션을 시작할 수 없으므로 주의**
- **Undo tablespace truncate:** 언두 테이블스페이스 공간을 필요한 만큼만 남기고 불필요하거나 과도하게 할당된 공간을 운영체제로 반납하는 것
	- 8.0부터 자동/수동으로 truncate하는 방법을 제공
	  ![[Screenshot 2023-11-21 at 5.45.33 PM.png]]

### 체인지 버퍼
- **레코드가 INSERT, UPDATE될 때는 데이터 파일 변경과 테이블 인덱스를 업데이트하는 작업도 필요**
	- 인덱스 업데이트 작업은 랜덤 디스크 읽기 작업이 필요하여 인덱스가 많은 경우 자원 소모가 심함
		- 따라서, 인덱스 페이지가 버퍼 풀에 있다면 바로 업데이트 수행
		- 그렇지 않다면 임시 공간에 저장해두고 사용자에게 결과를 반환하는 형태로 성능을 향상
			- 이 임시 공간을 체인지 버퍼라고 함
- 다만 **중복 여부를 체크해야 하는 유니크 인덱스는 체인지 버퍼를 사용할 수 없음**
	- 체인지 버퍼에 임시로 저장된 인덱스 레코드 조각은 백그라운드 스레드(체인지 버퍼 머지 스레드)에 의해 병합
	- 5.5 이전까지는 INSERT 작업에 대한 버퍼링이 가능했으나,
	- 5.5부터 개선되며 8.0에서는 데이터 변경 명령어로 키 추가/삭제하는 작업에 대해서도 버퍼링이 가능해짐
		- `innodb_change_buffering`으로 작업 종류별로 체인지 버퍼를 활성화할 수 있음
		- ![[Screenshot 2023-11-21 at 5.50.17 PM.png]]
- 기본적으로 버퍼 풀 전체 메모리 공간의 25%까지 사용할 수 있고, 최대 50%까지 사용할 수 있음
	- `innodb_change_buffer_max_size`를 설정하여 최대 메모리 공간 늘릴 수 있음

### 리두 로그 및 로그 버퍼
- 대부분 DBMS는 **데이터베이스 복구 및 쓰기 성능 향상을 위해 리두 로그를 활용**
	- mysql 서버 비정상 종료 시 아래 종류의 일관되지 않은 데이터를 가질 수 있음
		- **커밋됐지만 데이터 파일에 기록되지 않은 데이터**
			- 리두 로그에 저장된 데이터를 데이터 파일에 다시 복사하면 됨
		- **롤백됐지만 데이터 파일에 이미 기록된 데이터**
			- 언두 로그 내용을 가져와 데이터 파일에 복사하면 됨
				- 변경이 커밋되었는지, 롤백되었는지 상태 확인을 위해서 리두 로그가 필요함
- 리두 로그는 트랜잭션이 커밋되면 즉시 디스크로 기록되도록 시스템 변수를 설정하는 것을 권장
	- 그래야 장애 직전까지 복구가 가능
	- 다만 성능 부하를 유발하므로, `innodb_flush_log_at_trx_commit`을 통해 리두 로그 디스크 동기화 주기 설정 가능
		![[Screenshot 2023-11-21 at 5.57.45 PM.png]]
- 리두 로그 전체 크기는 버퍼 풀의 효율성을 결정하므로 주의해야 함
	- `innodb_log_file_size`로 리두 로그 전체 크기를 설정 가능
	- `innodb_log_files_in_group`: 리두 로그 파일 개수 결정 가능

**로그 버퍼**
- ==리두 로그 작업 성능 향상을 위해 ACID를 보장하는 수준에서 버퍼링하는 공간==
- 기본값인 16MB 수준에서 BLOB/TEXT 등 큰 데이터를 자주 변경하는 경우 더 크게 설정하는 것을 권장

**리두 로그 아카이빙**
- 8.0부터 리두 로그를 아카이빙할 수 있는 기능 추가
	- mysql 엔터프라이즈 백업이나 Xtrabackup 툴은 데이터 파일을 복사하는 동안 리두 로그에 쌓인 내용을 추적하며 새로 추가된 리두 로그 엔트리를 복사
	- 데이터 파일을 복사하는 동안 추가된 리두 로그 엔트리가 같이 백업되지 않는다면, 복사된 데이터 백업 파일이 일관된 상태를 유지하지 못함
	- 데이터 변경이 너무 많을 시, 리두 로그가 매우 빠르게 증가하여 백업 프로그램이 리두 로그 내용을 복사하기 전 덮어씌워질 수 있어 백업에 실패할 수 있음
	- 리두 로그 아카이빙 기능을 사용하여 리두 로그가 덮어씌워지더라도 백업이 실패하지 않게 할 수 있음
- `innodb_redo_log_archive_dirs`를 설정하여 리두 로그 저장 디렉토리 설정
	- 운영체제 mysql 서버 실행 유저만 접근 가능해야 함
	- 다음과 같이 리두 로그 아카이빙을 시작할 수 있음
	  ![[Screenshot 2023-11-21 at 6.06.51 PM.png]]
	- 리두 로그 아카이빙은 다음과 같이 종료할 수 있음
	  ![[Screenshot 2023-11-21 at 6.07.55 PM.png]]
	- 아카이빙 파일이 삭제되는 것은 아니므로 파일은 수동으로 삭제해야 함
	- 아카이빙을 시작한 세션이 아카이빙을 종료하지 않고 끊어지면 InnoDB가 아카이빙 파일도 삭제해버리므로 주의

**리두 로그 활성화 및 비활성화**
- 기본적으로 리두 로그는 언제나 활성화되어있었음
- 8.0부터 리두 로그 비활성화 가능
	- 데이터를 복구하거나 대용량 데이터를 한번에 적재하는 경우 리두 로그를 비활성화하여 데이터 적재 시간을 단축시킬 수 있음
	  ![[Screenshot 2023-11-21 at 6.10.49 PM.png]]
	  ![[Screenshot 2023-11-21 at 6.10.58 PM.png]]
	- 어느 정도 데이터 손실을 감수할 수 있다해도 리두 로그 비활성화보다 `innodb_flush_log_at_trx_commit` 시스템 변수를 0이나 2로 설정하는 것을 권장

### 어댑티브 해시 인덱스
- ==InnoDB가 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스==
	- `innodb_adaptive_hash_index`: 기능 활성화 여부 설정 가능
- ==B-Tree 검색 시간을 줄이는 것이 주 목적==
	- B-Tree 인덱스는 서버가 얼마나 많은 일을 하냐에 따라 느릴 수도, 빠를 수도 있음
	- 루트 노드 -> 브랜치 노드 -> 리프 노드를 찾아야 레코드를 찾을 수 있는데, 동시에 많은 스레드가 실행한다면 쿼리 성능이 떨어질 수 있음
- 자주 읽히는 데이터 페이지 키 값을 사용해 해시 인덱스를 만들어 레코드가 저장된 데이터 페이지를 즉시 찾아갈 수 있음
	- **해시 인덱스는 (인덱스 키 값, 인덱스 키 값이 저장된 데이터 페이지 주소) 형식**
		- 인덱스 키 값은 (B-Tree 인덱스 고유 번호, B-Tree 인덱스 실제 키 값) 형식
			- 서버에서 어댑티브 해시 인덱스가 하나만 존재하므로 어떤 B-Tree 인덱스에 속해있는지 확인이 필요해 B-Tree 인덱스 고유 번호가 포함됨
		- 데이터 페이지 주소를 값으로 가지므로 데이터 페이지가 사라진다면 어댑티브 해시 인덱스에서도 사라짐
- 8.0 이전까지는 어댑티브 해시 인덱스가 한 메모리 객체라 잠금 경합이 심했으나, 8.0부터 어댑티브 해시 인덱스 파티션 기능을 제공하여 경합을 감소시킬 수 있도록 함
	- `innodb_adaptive_hash_index_parts`: 어댑티브 해시 인덱스 파티션 개수 설정 가능
		- 기본값 8개
- 다음 상황에서는 어댑티브 해시 인덱스가 크게 도움되지 않을 수 있음
  ![[Screenshot 2023-11-21 at 6.22.32 PM.png]]
- 다음 상황에서 특히 도움됨
  ![[Screenshot 2023-11-21 at 6.22.18 PM.png]]
- 어댑티브 해시 인덱스는 데이터 페이지를 메모리 내에서 접근하는 것을 빠르게 하는 기능
	- 데이터 페이지를 디스크에서 읽는 경우가 많다면 도움되지 않음
	- 메모리를 사용하고, 때론 상당한 양이 요구될 수 있음
	- 조회/업데이트 등 추가 관리 비용 발생
		- 특히 테이블 삭제 시 관련 모든 데이터 페이지를 어댑티브 해시 인덱스에서 제거해야 함
- InnoDB 상태 결과에서 어댑티브 해시 인덱스 히트율과 메모리 공간 크기를 확인하여 비활성화 여부를 판단하는 것을 권장
  ![[Screenshot 2023-11-21 at 6.26.31 PM.png]]

### InnoDB와 myisam, memory 스토리지 엔진 비교
- 5.5부터 InnoDB가 디폴트로 채택
	- 다만 mysql 서버 시스템 테이블은 여전히 myisam 테이블 사용
	- 전문 검색/공간 좌표 검색 등은 myisam 테이블에서만 지원됨
- 8.0부터 mysql 모든 시스템 테이블이 InnoDB로 교체, 공간 좌표 검색/전문 검색 모두 InnoDB 지원 가능하도록 개선
	- 이후 버전에서 없어질 것이라 예상
- memory 또한 동시 처리 성능에 있어 InnoDB를 따라갈 수 없음
	- 5.7 버전까지 내부적으로 임시 테이블을 사용할 때 사용되었으나, 가변 길이 타입 칼럼을 지원하지 않아 8.0부터 TempTable이 대체되어 사용되고 있음
	- 이후 버전에서 없어질 것이라 예상

## myisam 스토리지 엔진 아키텍처
![[Screenshot 2023-11-21 at 3.13.32 AM.png]]
### 키 캐시
- InnoDB의 버퍼 풀과 비슷한 역할
- 인덱스만을 대상으로 작동하며, 인덱스 디스크 쓰기 작업에 대해서만 부분적으로 버퍼링 역할을 수행
- 다음과 같이 키 캐시 히트율 계산 가능
  ![[Screenshot 2023-11-21 at 6.32.04 PM.png]]
	- `key_reads`: 인덱스를 디스크에서 읽어들인 횟수
	- `key_read_requests`: 키 캐시에서 인덱스를 읽은 횟수
		- 두 값은 다음과 같이 확인 가능
		  ![[Screenshot 2023-11-21 at 6.33.06 PM.png]]
	- 일반적으로 히트율을 99% 이상으로 유지하는 것을 권장
		- 99% 미만이라면 키 캐시를 조금 더 크게 설정하는 것을 추천
		- 32bit에서 한 키 캐시당 4GB, 64bit 운영 체제에서 `OS_PER_PROCESS_LIMIT` 크기만큼 메모리 공간 할당 가능
			- 제한값 이상 키 캐시를 할당하고 싶으면 별도 이름이 붙은 키 캐시 공간을 다음과 같이 설정해야 함
			  ![[Screenshot 2023-11-21 at 6.35.13 PM.png]]
			![[Screenshot 2023-11-21 at 6.35.41 PM.png]]
			- 별도 이름이 붙은 키 캐시 공간에 어떤 인덱스를 캐시할지 설정해야 함
				- 설정하지 않으면 메모리만 잡아먹고 아무런 사용을 하지 않게 됨

### 운영체제의 캐시 및 버퍼
- 디스크 IO를 해결할 캐시나 버퍼링 기능 없음
	- 따라서 항상 운영체제 디스크 IO 작업으로 요청됨
- 운영체제 캐시 공간은 남는 메모리를 사용하는 것이 원칙이므로, 다른 애플리케이션에서 메모리를 모두 사용하면 캐시 용도로 사용할 수 있는 메모리 공간이 없음
	- 따라서 키 캐시를 최대 물리 메모리 40% 이하로 설정하고, 나머지 메모리를 운영체제에게 사용할 수 있도록 하는 것을 권장

### 데이터 파일과 프라이머리 키 구조
- 프라이머리 키에 의한 클러스터링 없이 데이터 파일이 힙 공간처럼 활용됨
	- myisam 테이블의 레코드는 프라이머리 키값과 무관하게 INSERT 되는 순대로 데이터파일에 저장됨
	- myisam 테이블에 저장되는 레코드는 모두 ROWID라는 물리적 주솟값을 가지며, 프라이머리 키, 세컨더리 인덱스 모두 ROWID 값을 포인터로 가짐
- ROWID는 가변 길이/고정 길이 두 가지 방법으로 저장될 수 있음
  ![[Screenshot 2023-11-21 at 6.40.47 PM.png]]

## mysql 로그 파일

### 에러 로그 파일
- mysql 실행 중 발생하는 에러/경고 메시지가 출력되는 로그 파일
	- `my.cnf`에서 `log_error` 라는 이름의 파라미터로 정의된 경로에 생성0됨
	- 별도로 정의되지 않은 경우, 데이터 디렉터리의 `.err` 확장자가 붙은 파일로 생성됨
- 자주 볼 수 있는 에러 메시지는 다음과 같음
	- **mysql이 시작하는 과정과 관련된 정보성 및 에러 메시지**
		- 설정 파일 변경/비정상 종료 이후 재시작하는 경우 에러 로그 파일을 통해 설정된 변수 이름/값이 명확하게 설정되고 적용되었는지 확인해야 함
			- 관련 변수의 특별한 에러나 경고성 메시지가 없다면 정상 적용된 것으로 판단하면 됨
			- ignore된 경우: 파라미터가 적용되지 못했음을 의미
			- 변수명/값을 인식하지 못하는 경우: 에러 메시지 확인
	- **비정상적으로 종료된 경우 나타나는 InnoDB 트랜잭션 복구 메시지**
		- 재시작 후 복구 과정에서 간단한 메시지 출력
			- 이 때, 문제가 있어 복구되지 못한다면 에러 메시지 출력 후 mysql 종료
	- **쿼리 처리 도중 발생하는 문제에 대한 에러 메시지**
		- 사전 예방이 어렵고 주기적으로 에러 로그 파일 검토 과정에서 발견됨
		- 쿼리 실행 도중 발생한 에러 혹은 복제에서 문제가 될 만한 쿼리에 대한 경고 메시지가 포함되므로 주기적 확인 권장
	- **비정상적으로 종료된 커넥션 메시지**
		- 클라이언트 애플리케이션에서 정상 접속 종료를 하지 못하고 프로그램이 종료된 경우 남는 메시지
		- 아주 많이 기록된다면 애플리케이션 커넥션 종료 로직 검토 필요
			- `max_connect_errors` 시스템 변수값 설정 권장 혹은 원인 파악 필요
	- **InnoDB 모니터링 또는 상태 조회 명령 결과 메시지**
		- InnoDB 테이블 모니터링, 락 모니터링, InnoDB 엔진 상태 조회 명령은 상대적으로 큰 메시지를 기록
		- InnoDB 모니터링 활성화 상태로 두고 유지한다면 에러 로그 파일이 매우 커져 디스크 사용량 문제가 발생할 수 있음
	- **mysql 종료 메시지**
		- mysql이 갑자기 종료되거나 재시작되는 경우, 원인을 파악할 수 있는 유일한 방법

### 제너럴 쿼리 로그 파일 (General log)
- ==쿼리 로그를 활성화해 요청된 쿼리를 쿼리 로그 파일로 기록한 것==
	- 시간 단위로 실행됐던 쿼리 내용이 모두 기록됨
		- 쿼리 실행 중 에러가 발생하더라도 기록됨
	- `general_log_file` 파라미터로 쿼리 로그 파일 경로 설정 가능
		- `log_output` 파라미터를 설정하여 테이블에 저장하도록 설정할 수 있음

### 슬로우 쿼리 로그
- ==`long_query_time`에 설정한 시간 이상 시간이 소요된 쿼리가 기록된 로그== 
	- 서비스 운영 중 mysql 서버 전체 성능 저하 검사 혹은 정기적 점검을 위한 튜닝 시에 유용
	- 정상적으로 실행돼야 슬로우 쿼리에 기록됨
- `log_output` 파라미터를 설정하여 테이블에 저장하도록 설정할 수 있음
	- 다만 CSV 스토리지 엔진을 사용하므로 CSV 파일로 기록됨
- **슬로우 쿼리 로그 예시**
	  ![[Screenshot 2023-11-21 at 6.54.56 PM.png]]	  ![[Screenshot 2023-11-21 at 6.55.04 PM.png]]
- 슬로우 쿼리, 제너럴 로그 파일 내용이 상당히 많아 하나씩 검토하기 어려운 경우,
   `pt-query-digest` 스크립트를 이용해 빈도/처리 성능별로 다음과 같이 세 개의 그룹으로 쿼리를 정렬하여 살펴볼 수 있음
	- 슬로우 쿼리 통계
	- 실행 빈도 및 누적 실행 시간순 랭킹
	- 쿼리별 실행 횟수 및 누적 실행 시간 상세 정보