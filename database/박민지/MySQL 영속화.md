# 영속화

데이터베이스에 저장된 데이터와 메타데이터가 **장애나 시스템 종료 후에도 유지**될 수 있도록 디스크에 저장하는 것

# 영속화 데이터 종류

**메타데이터 (데이터 사전)**
- 데이터베이스의 구조와 관련된 **메타데이터**도 영속화되어야 합니다. 여기에는 테이블, 인덱스, 트리거, 뷰, 저장 프로시저 등의 정의와 속성이 포함됩니다. 이러한 메타데이터는 MySQL의 **데이터 사전(System Catalog)**에 저장됩니다.
	- 테이블과 컬럼의 정의 (`CREATE TABLE`, `ALTER TABLE` 등)
	- 인덱스 정보 (`CREATE INDEX`, `DROP INDEX`)
	- 데이터베이스, 테이블, 컬럼의 속성 및 제한 조건 (예: 기본키, 외래키, 데이터 타입 등)
	- DDL 명령어로 변경된 메타데이터는 MySQL에서 즉시 영속화됩니다.

**Redo 로그**
- **데이터베이스 충돌 복구**를 위해 사용되는 **디스크 기반 데이터 구조**
- Redo Log는 **InnoDB 스토리지 엔진**에서 **데이터 일관성**을 보장하며, 예기치 않은 시스템 종료 후 미완성된 트랜잭션을 복구하는 데 사용됩니다.
- 특징
	- **물리적 로그:** **데이터 페이지**에서 변경된 **실제 값**을 기록합니다.
	- **충돌 복구**: 시스템이 비정상 종료된 후, Redo Log는 트랜잭션 중 완료되지 못한 **데이터 수정 작업을 복구**합니다.
	- **데이터 변경 기록**: **SQL 문장** 또는 **저수준 API 호출**에 의해 발생한 테이블 데이터 변경 요청이 Redo Log에 기록됩니다. 데이터 파일에 쓰여지지 못한 변경 사항들은 Redo Log에 의해 시스템 재시작 시 복원됩니다.
	- **LSN 값**: Redo Log는 **LSN (Log Sequence Number)**라는 증가하는 값으로 관리되며, 데이터가 변경될 때마다 새로운 Redo 기록이 추가되고 가장 오래된 기록은 **체크포인트**가 진행되면서 삭제됩니다.
	- Redo Log의 데이터 흐름은 **체크포인트**를 기준으로 진행되며, 데이터 파일에 저장된 후 Redo Log에서 제거됩니다.
	- Write-log-logging

**Undo 로그**
- **Undo 로그**는 트랜잭션이 롤백될 때 데이터를 원래 상태로 되돌리기 위한 로그입니다. 트랜잭션이 커밋되지 않았거나 롤백될 경우 변경된 데이터를 복구하기 위해 Undo 로그가 사용됩니다. Undo 로그 역시 메모리와 디스크에 영속적으로 저장됩니다.
- 만약 다른 트랜잭션이 **일관된 읽기(consistent read)** 작업을 수행할 때 원본 데이터를 볼 필요가 있다면, 수정되지 않은 데이터는 **Undo 로그 레코드**에서 가져옵니다.
- 특히 트랜잭션이 실패하거나 `ROLLBACK` 명령어가 실행될 때 Undo 로그는 변경된 데이터를 되돌리는 데 사용됩니다.

**Binary Log (바이너리 로그)**
- **바이너리 로그**는 MySQL의 모든 변경 사항(DML 및 DDL 명령어)을 기록하는 로그 파일입니다. 이는 데이터 복제 및 장애 복구에 중요한 역할을 합니다.
	- **복제**: 바이너리 로그는 마스터 서버에서 슬레이브 서버로 데이터를 복제할 때 사용됩니다.
	- **Point-in-Time 복구(PITR)**: 바이너리 로그를 사용하면 특정 시점으로 데이터베이스를 복구할 수 있습니다.
	- **논리적 로그:** 트랜잭션이 수행한 **SQL 명령어** 또는 **트랜잭션 변경 내용**을 기록합니다.

**InnoDB 테이블 스페이스**
- InnoDB의 테이블 스페이스는 데이터와 인덱스를 디스크에 저장하는 물리적 파일입니다. MySQL에서는 각 테이블의 데이터와 인덱스가 영속적으로 저장되며, 테이블에 저장된 데이터는 `.ibd` 파일 형식으로 저장됩니다.
- 테이블 스페이스는 데이터베이스의 **데이터 파일**을 의미하며, 실제 데이터와 인덱스가 이 공간에 저장됩니다.
- 테이블 스페이스는 MySQL 서버가 중단되거나 재시작될 때 데이터가 유지되도록 보장합니다.

**InnoDB 버퍼 풀과 플러시**
- InnoDB는 메모리에서 데이터를 캐시하는 **버퍼 풀(Buffer Pool)**을 사용합니다. 그러나 메모리만으로는 영속적인 저장이 불가능하므로, 버퍼 풀의 데이터를 주기적으로 디스크로 **플러시(flush)** 해야 합니다. 영속화를 위해서는 버퍼 풀에 있는 데이터가 안전하게 디스크에 기록되어야 합니다.
- MySQL은 자동으로 또는 수동으로 버퍼 풀의 데이터를 디스크로 플러시합니다.
- 플러시가 이루어지지 않으면 서버가 다운되었을 때 데이터 손실이 발생할 수 있습니다.

**트리거(Triggers)**
- MySQL에서 정의된 **트리거**는 특정 테이블에서 이벤트가 발생할 때 자동으로 실행되는 명령어 집합입니다. 트리거 정의 역시 메타데이터의 일부로서 영속적으로 저장되어야 하며, 서버 재시작 후에도 유지됩니다.

**저장 프로시저(Stored Procedures)와 함수(Functions)**
- **저장 프로시저**와 **함수**는 데이터베이스 내에서 실행될 수 있는 SQL 코드의 집합으로, 이를 정의하고 유지하는 메타데이터 역시 영속적으로 저장됩니다. 저장 프로시저와 함수는 서버 재시작 후에도 유지되며, 계속 사용할 수 있어야 합니다.

**이벤트(Event Scheduler)**
- MySQL의 **이벤트 스케줄러**를 사용하면 특정 시간에 자동으로 실행되는 SQL 작업을 정의할 수 있습니다. 이러한 이벤트 정의도 영속적으로 저장되어, MySQL 서버 재시작 후에도 계속 작동할 수 있어야 합니다.

**사용자 계정 및 권한**
- MySQL 데이터베이스에서 생성된 **사용자 계정**과 **접근 권한** 역시 영속적으로 저장됩니다. 사용자의 권한 및 인증 정보는 MySQL의 **시스템 테이블**에 저장되며, 서버 재시작 후에도 계속해서 유지되어야 합니다.
- 계정 정보는 `mysql` 데이터베이스의 `user`, `db`, `tables_priv` 등의 테이블에 저장됩니다.


# DDL 처리 과정 (InnoDB 스토리지 엔진 기준)

1. **DDL 명령어 수신 및 파싱**
	- MySQL 서버가 DDL 명령어를 받으면, **SQL 파서**가 명령어를 분석합니다. 이 단계에서 MySQL은 SQL 문법을 검사하고, 내부적으로 해당 명령어가 어떤 작업을 수행해야 하는지 분석합니다.
	- 파싱이 끝나면, MySQL은 이 명령어가 어떤 테이블이나 데이터베이스에 영향을 미치는지 확인하고 메타데이터를 업데이트할 준비를 합니다.

2. **InnoDB 엔진의 메타데이터 락 (MDL: Metadata Lock)**
	- DDL 명령어가 테이블이나 데이터베이스 구조를 변경하는 것이기 때문에, 이를 수행하기 전에 **메타데이터 락(MDL)**이 걸립니다. 이는 다른 트랜잭션이 해당 테이블을 동시에 수정하거나 참조하지 않도록 하기 위함입니다.
	- MDL은 테이블의 **스키마 변경**을 안전하게 처리하기 위한 잠금이며, MySQL 5.5부터 도입되었습니다.

3. **테이블 및 인덱스 메타데이터 수정**
	- MySQL은 먼저 해당 테이블의 **메타데이터**를 수정합니다. 메타데이터는 테이블의 구조, 인덱스 정보, 컬럼 정보 등을 포함하며, 이는 **.frm** 파일(5.7 버전 이전) 또는 **data dictionary**(8.0 버전 이후)에 저장됩니다.
	- MySQL 8.0 이후부터는 메타데이터는 **InnoDB 시스템 테이블**에 저장되며, 메타데이터 파일은 별도로 존재하지 않습니다. 이는 일관성을 높이기 위한 변경입니다.

4. **Undo 로그 버퍼 기록**
	- **Undo 로그**는 트랜잭션이 롤백될 경우 데이터를 복구할 수 있도록 이전 상태를 저장하는 로그입니다. DDL 명령어도 트랜잭션의 일환으로 처리되기 때문에, 롤백 가능성을 대비하여 Undo 로그에 변경 전 데이터를 기록합니다.
	- 예를 들어, 테이블이 삭제되면 해당 테이블의 이전 상태가 Undo 로그에 저장되어 롤백이 가능하도록 보장합니다.

5. **Redo 로그 버퍼 기록**
	- InnoDB는 ACID 트랜잭션을 보장하기 위해 **Redo 로그**를 사용합니다. DDL 명령어에 의해 발생한 데이터 변경 사항은 먼저 **Redo 로그**에 기록됩니다.
	- Redo 로그는 **WAL(Write-Ahead Logging)** 기법을 사용합니다. 즉, 변경 사항을 실제로 데이터 파일에 쓰기 전에 Redo 로그에 먼저 기록하여 시스템이 비정상 종료되더라도 데이터 복구가 가능하도록 합니다.
	- 예를 들어, 테이블을 생성하는 `CREATE TABLE` 명령어가 실행되면, 해당 작업이 Redo 로그에 기록됩니다.

6. **Buffer Pool에 데이터 반영**
	- DDL 명령어에 의한 변경 사항은 먼저 InnoDB의 **Buffer Pool**에 저장됩니다. Buffer Pool은 메모리 상에서 데이터와 인덱스 페이지를 캐시하는 역할을 하며, 실제로 디스크에 기록되기 전에 메모리에서 일시적으로 변경된 데이터를 보관합니다.
	- Buffer Pool은 주기적으로 **Checkpoint**를 발생시켜, 메모리 상의 변경 사항을 **데이터 파일**에 기록합니다.

7. **파일 시스템 상의 물리적 변경**
	- **Buffer Pool**에 있는 데이터가 디스크로 **Flush**되면, 변경된 데이터는 디스크 상의 **데이터 파일**로 기록됩니다. InnoDB에서는 이 데이터가 **다중 파일 시스템 구조**로 저장됩니다:
	    - **.ibd 파일**: 각 테이블의 실제 데이터와 인덱스가 저장되는 파일입니다. 이 파일은 **InnoDB** 스토리지 엔진이 관리하는 데이터 파일로, 테이블마다 별도의 `.ibd` 파일이 생성됩니다.
	    - **시스템 테이블 스페이스**: InnoDB의 시스템 테이블과 일부 테이블이 기록되는 곳으로, 이는 InnoDB가 관리하는 내부 시스템 데이터입니다.

8. **DDL 완료 및 커밋**
	- 모든 작업이 완료되면, MySQL은 DDL 명령어에 대한 변경 사항을 **커밋**합니다. 이때 **Redo 로그**와 **Undo 로그**에 기록된 내용이 커밋되며, 트랜잭션이 완료됩니다.

9. **Binlog 기록**
	- MySQL은 **binary log (binlog)**에 DDL 명령어의 실행 내용을 기록합니다. 이는 데이터베이스 복제 및 Point-in-Time Recovery(PITR)를 위해 필요합니다.
	- `CREATE TABLE` 또는 `ALTER TABLE` 같은 DDL 명령어가 실행되면, binlog에 해당 명령어가 기록되어 복제본 서버에서 동일한 명령어가 실행될 수 있도록 합니다.
	- binlog는 트랜잭션이 **커밋**되었을 때 기록됩니다.

10. **메타데이터 락 해제**
	- 커밋과 Binlog 기록이 완료되면, 메타데이터 락이 해제되고 다른 트랜잭션이 해당 테이블에 접근할 수 있게 됩니다.


# DML 처리 과정 (InnoDB 스토리지 엔진 기준)
1. **DML 명령어 수신 및 파싱**
    - MySQL 서버는 **INSERT**, **UPDATE**, **DELETE** 등의 DML 명령어를 수신하면 **SQL 파서**를 통해 명령어를 분석합니다.
    - 이 단계에서 MySQL은 SQL 문법을 검사하고, 명령어가 수행해야 할 작업을 이해한 뒤, 데이터베이스에 어떤 영향을 미치는지 확인합니다.
    - 예를 들어, `UPDATE` 명령어가 특정 테이블의 어느 행을 수정하는지 결정합니다.

2. **InnoDB 엔진의 레코드 잠금 (Record Locking)**
    - DML 명령어는 **트랜잭션의 일환**으로 실행되므로, InnoDB는 **행 레벨 잠금(row-level locking)**을 사용하여 해당 레코드를 보호합니다.
    - **공유 잠금(Shared Lock)** 또는 **배타 잠금(Exclusive Lock)**이 적용되며, 이는 다른 트랜잭션이 동시에 동일한 데이터를 수정하지 못하도록 보호합니다.
    - 이 잠금은 트랜잭션이 완료될 때까지 유지되며, **MVCC**(Multiversion Concurrency Control)를 통해 고립성을 보장합니다.

3. **Undo 로그 버퍼 기록**    
    - InnoDB는 트랜잭션의 **원자성(Atomicity)**을 보장하기 위해 **Undo 로그**를 사용합니다.
    - DML 명령어가 데이터를 변경하기 전에, 변경될 **이전 값**이 **Undo 로그**에 기록됩니다.
    - 만약 트랜잭션이 롤백될 경우, Undo 로그를 참조하여 데이터를 이전 상태로 복원할 수 있습니다.

4. **Redo 로그 버퍼 기록**
    - 트랜잭션이 **데이터를 변경**할 때, InnoDB는 해당 변경 사항을 **Redo 로그**에 기록합니다.
    - Redo 로그는 트랜잭션이 커밋되기 전에도 기록되며, 시스템이 비정상 종료되더라도 변경 사항을 복구할 수 있게 합니다. 이 과정은 **Write-Ahead Logging(WAL)** 기법을 사용합니다.
    - 트랜잭션이 커밋되기 전까지 **Redo 로그 버퍼**에 저장되며, 이후 디스크로 플러시됩니다.

5. **Buffer Pool에 데이터 반영**
    - 실제로 데이터 변경이 **InnoDB의 Buffer Pool**에 적용됩니다.
    - Buffer Pool은 메모리 내에서 데이터와 인덱스 페이지를 캐싱하는 역할을 하며, **변경된 데이터는 메모리에 먼저 반영**되고, 나중에 디스크로 기록됩니다.
    - 주기적으로 발생하는 **Checkpoint**에 의해 Buffer Pool의 내용이 **데이터 파일**로 기록됩니다.

7. **트랜잭션 커밋**
    - 모든 데이터 변경이 완료되면, 트랜잭션이 **커밋**됩니다.
    - 트랜잭션이 커밋됨으로써, 트랜잭션에 포함된 모든 변경 사항이 **영구적**으로 기록됩니다. 커밋이 완료되면 **Redo 로그**의 기록이 확정됩니다.
    - **커밋이 완료되면**, 트랜잭션이 성공적으로 종료되고, 데이터 변경 사항이 영구적으로 반영됩니다.

1. **변경된 데이터의 플러시 및 파일 시스템 상의 물리적 변경**
    - **Buffer Pool**에 반영된 변경 사항은 주기적으로 또는 커밋 시점에 디스크로 플러시됩니다.
    - 이때 **.ibd 파일**(각 테이블의 데이터 및 인덱스 저장) 또는 **시스템 테이블 스페이스**로 기록됩니다.
    - 디스크로 플러시되는 시점은 MySQL의 **checkpoint**나 **커밋 시점**에서 이루어질 수 있습니다.

2. **Binlog 기록**
    - **트랜잭션이 커밋된 후**, MySQL은 **binary log (binlog)**에 트랜잭션의 변경 사항을 기록합니다.
    - Binlog는 **복제(replication)** 및 **Point-in-Time Recovery (PITR)**를 위해 사용되며, DML 명령어에 의한 데이터 변경 사항도 기록됩니다.
    - **2단계 커밋(two-phase commit)**을 통해 Redo 로그와 Binlog의 일관성을 유지하며, 이를 통해 데이터 복제 및 복구 작업을 안전하게 처리합니다.

3. **행 잠금 해제**
    - 트랜잭션이 커밋되거나 롤백되면, InnoDB는 해당 트랜잭션이 걸었던 **레코드 잠금**을 해제합니다.
    - 이를 통해 다른 트랜잭션이 해당 데이터에 접근할 수 있습니다.


# References
- https://dev.mysql.com/doc/refman/8.4/en/innodb-undo-logs.html