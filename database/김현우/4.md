# 쿼리 실행 과정

## Query Optimization (EXPLAIN, Joins, Subqueries)

### 인덱스 활용
인덱스는 데이터베이스 테이블에서 특정 열에 대한 검색 속도를 빠르게 해줍니다. 자주 조회하거나 조건으로 사용하는 열에 인덱스를 생성하는 것이 성능 향상에 도움이 된다.

### 불필요한 데이터 조회 최소화
SELECT *처럼 모든 데이터를 조회하는 쿼리보다는 필요한 열만 선택적으로 조회하는 것이 성능에 더  좋음.

### 조인(Join) 최적화
여러 테이블을 조인할 때는 각 테이블에 적절한 인덱스가 있는지 확인하고, 조인의 순서나 조건을 최적화해야 합니다.

특히 대량의 데이터를 조인하는 경우, INNER JOIN이 불필요한 데이터까지 조회하지 않도록 설계되어 있는지 확인하는 것이 중요합니다.

### 서브쿼리 대신 조인 사용
일부 상황에서는 서브쿼리 대신 **조인(Join)**을 사용하는 것이 더 빠를 수 있습니다. 서브쿼리는 데이터베이스가 여러 번 쿼리를 수행해야 하기 때문에 성능에 영향을 미칠 수 있습니다.

### 쿼리 실행 계획 분석
대부분의 데이터베이스는 쿼리 실행 계획(Execution Plan)을 제공합니다. 이 계획을 통해 쿼리가 어떻게 실행되는지 확인하고, 병목이 되는 부분을 찾아 최적화할 수 있습니다.

예를 들어, MySQL에서는 EXPLAIN 명령어를 사용하여 쿼리 실행 계획을 확인할 수 있음.

### 데이터베이스 구조 최적화
정규화를 통해 데이터 중복을 최소화하고, 비정규화를 통해 성능을 개선할 수 있습니다. 예를 들어, 조인을 자주 사용하는 테이블의 데이터를 하나로 합치는 것도 하나의 전략입니다.
또한, 파티셔닝을 통해 큰 테이블을 나누어 관리하는 방법도 성능 개선에 효과적입니다.

### 캐시 사용
쿼리의 결과를 캐싱함으로써 같은 데이터를 반복해서 조회할 필요 없이 빠르게 응답할 수 있습니다. 애플리케이션 레벨에서 Redis 같은 캐시를 사용할 수 있고, 데이터베이스 레벨에서도 쿼리 캐시를 사용할 수 있습니다.

### LIMIT 절 사용
많은 양의 데이터를 조회할 때는 필요 없는 데이터를 읽지 않도록 LIMIT 절을 사용하는 것이 좋습니다. 이는 특히 페이지네이션 구현 시 유용합니다.

### 집계 함수 최적화
COUNT(), SUM() 등의 집계 함수를 사용할 때 불필요한 조건이나 데이터를 조회하지 않도록 신경 써야 합니다. 예를 들어, COUNT(*)보다는 특정 인덱스가 있는 열을 기준으로 COUNT(column)을 사용하는 것이 더 나을 수 있습니다.

## parser, Optimizer

### Parser

데이터베이스에서 쿼리를 실행하기 위해서는 먼저 쿼리를 분석하는 파서(Parser)가 필요합니다. 파서는 쿼리를 토큰으로 분리하고, 문법적 오류가 있는지 검사합니다. 이후, 파서는 파싱 트리를 생성하여 옵티마이저에게 전달합니다.

### Optimizer

옵티마이저(Optimizer)는 파서로부터 전달받은 파싱 트리를 최적화하여 실행 계획을 생성합니다. 이때, 옵티마이저는 다양한 실행 계획을 고려하고, 비용(cost)을 계산하여 최적의 실행 계획을 선택합니다.


[Explain 설명](https://velog.io/@ddongh1122/MySQL-%EC%8B%A4%ED%96%89%EA%B3%84%ED%9A%8D-EXPLAIN)