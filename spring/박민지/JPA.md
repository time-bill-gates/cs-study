# JPA(Java Persistence API)
자바에서 객체와 관계형 데이터베이스 간의 매핑을 처리하는 표준 명세

### 목적
- **객체와 데이터베이스 간의 매핑 (ORM)**
	- 자바 객체와 관계형 데이터베이스의 테이블을 자동으로 연결
	- JPA는 개발자가 테이블을 직접 다루지 않고 객체를 다루면서 데이터베이스 작업을 할 수 있도록 도와줍니다.
- **데이터베이스 독립성**
	- SQL을 직접 작성할 경우 특정 데이터베이스 벤더(예: MySQL, Oracle, PostgreSQL 등)에 의존하게 되지만, JPA는 벤더에 독립적인 방식으로 쿼리를 작성할 수 있습니다.
- **생산성 향상**
	- 반복적인 SQL 코드 작성을 줄여줍니다.
	- 간단한 CRUD(Create, Read, Update, Delete) 작업은 별도의 SQL 쿼리 작성 없이 JPA의 메서드 호출만으로 처리할 수 있습니다.
- **유지보수 및 코드 가독성 향상**
	- **비즈니스 로직을 더 명확하게 표현할 수 있게 해** 코드의 유지보수성을 향상시킵니다.
	- SQL을 직접 작성하는 것보다 객체 지향적인 방식으로 데이터를 처리할 수 있으므로, 코드를 읽고 이해하기가 더 쉬워집니다.
- **트랜잭션 관리 및 데이터 무결성**
	- 트랜잭션 관리를 간소화하여, 여러 작업을 하나의 트랜잭션으로 묶어 처리할 수 있게 합니다.
- **캐싱 및 성능 최적화**
	- 영속성 컨텍스트를 통해 **1차 캐시**를 제공합니다.
	- 또한, 지연 로딩(Lazy Loading)과 같은 기능을 통해 필요한 시점에만 데이터를 로드하여 성능을 최적화할 수 있습니다.

### 단점
- **복잡한 매핑 설정**
    - 복잡한 엔티티 매핑이 필요한 경우 설정이 복잡해질 수 있습니다. 테이블 간의 관계가 많거나, 상속 구조를 사용하는 경우 매핑 설정이 까다롭고 유지보수하기 어려울 수 있습니다.
    - 명확하게 설계되지 않은 경우 성능 문제나 예상치 못한 동작이 발생할 수 있습니다.
- **학습 곡선**
    - JPA는 사용하기 전 개념을 충분히 이해해야 합니다. 특히, 영속성 컨텍스트, 트랜잭션, 지연 로딩 등의 동작 방식을 제대로 파악하지 못하면 성능 문제나 데이터 일관성 문제가 발생할 수 있습니다.
    - 초보 개발자에게는 학습 곡선이 다소 가파릅니다.
- **성능 문제**
    - JPA가 자동으로 생성하는 SQL 쿼리가 항상 최적화되어 있지 않으며, 복잡한 쿼리에서는 성능 저하가 발생할 수 있습니다.
    - 특히 많은 데이터에 대해 일괄 처리(batch processing)를 수행하는 경우 SQL을 수동으로 최적화하지 않으면 성능 이슈가 발생할 수 있습니다.
- **JPQL의 한계**
    - JPQL은 SQL만큼 강력하지 않습니다. 복잡한 쿼리나 데이터베이스 벤더에 특화된 기능을 사용할 때는 JPQL만으로는 한계가 있어, 결국 네이티브 SQL을 사용해야 할 수도 있습니다.
- **지연 로딩과 즉시 로딩의 관리**
    - 기본적으로 JPA는 지연 로딩(Lazy Loading)을 사용하지만, 즉시 로딩(Eager Loading)과 혼합해서 사용하면 성능 및 데이터 일관성 문제가 발생할 수 있습니다.
    - 잘못 설정된 지연 로딩은 N+1 문제를 일으켜 성능을 저하시킬 수 있습니다.
- **추상화로 인한 제어의 어려움**
    - JPA는 대부분의 데이터베이스 작업을 추상화하지만, 그로 인해 세부 제어가 어려운 경우가 있습니다. 예를 들어, 복잡한 SQL 최적화나 특정 데이터베이스 기능을 사용할 때는 JPA의 추상화가 오히려 장애물이 될 수 있습니다.
- **캐싱 및 동시성 이슈**
    - JPA는 1차 캐시를 사용하여 성능을 최적화하지만, 동시성 문제가 발생할 수 있습니다. 특히 다중 스레드 환경에서 데이터 동기화 및 트랜잭션 관리를 신중히 해야 합니다.
	    - 캐시가 없어도 동시성 문제가 발생할 수 있지만, 동시성 문제가 발생할 수 있는 범위를 더 확장시킬 수 있습니다.

# JPA 주요 개념
### 엔티티
데이터베이스의 **테이블에 매핑되는 클래스**
- 각 엔티티 클래스는 테이블의 한 행(row)에 해당하며, 엔티티의 필드는 테이블의 열(column)에 매핑됩니다.

### 영속성 컨텍스트 (Persistence Context)
JPA가 제공하는 **엔티티 객체들의 생명 주기를 관리하는 환경**

#### 주요 역할
- **엔티티의 상태 관리**
    - 영속성 컨텍스트는 데이터베이스에서 조회된 엔티티나, 새로 생성된 엔티티를 메모리에서 관리합니다. JPA는 이 엔티티 객체를 **캐시**처럼 보관하고, 이를 통해 데이터베이스와의 상호작용을 줄여줍니다.
- **엔티티의 상태 동기화**
    - 트랜잭션이 종료되기 전까지, 영속성 컨텍스트는 엔티티의 상태 변화를 추적하고 있다가, 트랜잭션이 끝날 때 데이터베이스에 변경 사항을 자동으로 반영합니다. 이를 통해 개발자는 일일이 `UPDATE`, `INSERT`, `DELETE` 쿼리를 작성하지 않아도 됩니다.
- **엔티티 동일성 보장**
    - 영속성 컨텍스트는 동일한 엔티티에 대한 여러 번의 조회 요청이 있을 때, 데이터베이스에서 다시 조회하지 않고 **메모리에 저장된 엔티티 객체를 반환**합니다. 즉, 동일한 트랜잭션 내에서는 **같은 엔티티는 동일한 객체**로 취급됩니다.

#### 엔티티 생명 주기
![image](https://velog.velcdn.com/images%2Fxohoonx2%2Fpost%2F1e630e4e-eda1-4314-aa59-9dc126f09b1c%2Fksug2015-jpa3-jpa-11-638.jpeg)
- **비영속 상태(Transient)**:
    - 영속성 컨텍스트와 전혀 연관되지 않은 상태입니다.
    - 단순히 메모리에서 생성된 객체로, 아직 데이터베이스에 저장되지 않은 상태입니다.
    - 예: `new Entity()`로 객체를 생성한 후, 아직 `EntityManager`에 저장하지 않은 상태.
- **영속 상태(Managed)**:
    - 영속성 컨텍스트에 의해 관리되는 상태로, 데이터베이스에 저장된 객체이거나 `persist()` 메서드를 통해 저장된 상태입니다.
    - 이 상태에서는 엔티티의 변경 사항이 자동으로 감지되며, 트랜잭션이 종료될 때 데이터베이스에 반영됩니다.
    - 예: `entityManager.persist(entity)`로 영속성 컨텍스트에 추가된 객체.
- **준영속 상태(Detached)**:
    - 영속성 컨텍스트에서 더 이상 관리되지 않는 상태입니다.
    - 영속성 컨텍스트가 닫히거나 트랜잭션이 끝난 후, 영속 상태에 있던 객체가 준영속 상태가 됩니다. 더 이상 엔티티의 변경 사항이 데이터베이스에 반영되지 않습니다.
    - 예: `entityManager.detach(entity)`로 영속성 컨텍스트에서 객체를 분리한 상태.
- **삭제 상태(Removed)**:
    - 영속성 컨텍스트에 의해 관리되지만, 삭제 대기 상태입니다.
    - 트랜잭션이 종료될 때 `remove()` 메서드를 호출한 엔티티는 데이터베이스에서 삭제됩니다.
    - 예: `entityManager.remove(entity)`로 엔티티를 삭제하려고 할 때.

#### 기능
- **1차 캐시**
    - 영속성 컨텍스트는 **1차 캐시**로 동작합니다. 즉, 동일한 엔티티를 여러 번 조회할 때, 매번 데이터베이스에 접근하지 않고 메모리에 저장된 엔티티 객체를 반환합니다. 이를 통해 성능을 최적화할 수 있습니다.
- **변경 감지(Dirty Checking)**
    - 영속성 컨텍스트는 **변경 감지(Dirty Checking)**를 통해 엔티티 객체의 변경 사항을 자동으로 감지합니다. 개발자가 별도의 `UPDATE` 쿼리를 작성하지 않아도, 엔티티의 필드 값을 변경하면 트랜잭션이 종료될 때 자동으로 데이터베이스에 반영됩니다.
- **쓰기 지연(Batch Write)**
    - 영속성 컨텍스트는 트랜잭션이 끝날 때까지 변경 사항을 일괄로 처리하기 위해 **쓰기 지연**을 사용합니다. 즉, 변경된 데이터가 즉시 데이터베이스에 반영되지 않고, 트랜잭션 종료 시점에 한 번에 반영됩니다. 이를 통해 데이터베이스에 대한 과도한 쓰기 작업을 줄일 수 있습니다.
- **엔티티의 동일성 보장**
    - 영속성 컨텍스트 내에서는 동일한 엔티티를 여러 번 조회하더라도 동일한 객체로 취급됩니다. 이로 인해 트랜잭션 내에서 엔티티의 동일성이 보장됩니다.

#### 주의사항
1. **메모리 과다 사용**
    - 영속성 컨텍스트는 트랜잭션이 종료될 때까지 엔티티 객체를 메모리에 보관하기 때문에, 트랜잭션이 길어지거나 관리하는 엔티티가 많아지면 메모리 사용량이 증가할 수 있습니다.
2. **트랜잭션 관리**
    - 영속성 컨텍스트는 트랜잭션 범위 내에서만 엔티티의 변경 사항을 관리하므로, 트랜잭션 관리를 잘못하면 데이터가 예상대로 반영되지 않거나, 데이터 불일치 문제가 발생할 수 있습니다.

### JPQL (Java Persistence Query Language)
객체지향 쿼리 언어로, **엔티티 객체를 대상으로** 쿼리를 작성하는 방식
- SQL과 유사하지만, JPQL은 **데이터베이스 테이블이 아닌 엔티티 클래스**를 대상으로 쿼리를 실행합니다.

```jpql
String jpql = "SELECT u FROM User u WHERE u.username = :username";
List<User> users = entityManager.createQuery(jpql, User.class)
                                .setParameter("username", "john")
                                .getResultList();

```

### 매핑 어노테이션 (Mapping Annotations)
JPA는 객체와 데이터베이스 간의 매핑을 정의하기 위해 여러 가지 매핑 애너테이션을 제공합니다. 엔티티 간의 관계도 매핑을 통해 처리됩니다.

**기본적인 매핑 애너테이션:**

| **매핑 애너테이션**          | **설명 및 주의사항**                                                                                                                    | **사용 예시**                                                                  |
| --------------------- | -------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------- |
| **`@Entity`**         | 클래스가 **JPA 엔티티**임을 선언하며, 해당 클래스는 데이터베이스의 테이블에 매핑됩니다. 클래스는 기본 생성자를 가져야 하며, **기본 키**(`@Id`)를 반드시 설정해야 합니다.                         | `@Entity public class User { ... }`                                        |
| **`@Id`**             | **기본 키(Primary Key)**로 사용할 필드를 지정합니다. `@GeneratedValue`와 함께 사용하여 키 값을 자동 생성할 수 있습니다.                                             | `@Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id;` |
| **`@Column`**         | 엔티티 필드를 데이터베이스의 **컬럼**에 매핑하며, 컬럼의 이름, 길이, 제약 조건 등을 설정할 수 있습니다. 생략 시 필드명과 동일한 컬럼명이 사용됩니다. **유니크, 널 허용 여부** 등을 설정할 수 있습니다.         | `@Column(name = "user_name", length = 100, nullable = false)`              |
| **`@GeneratedValue`** | **기본 키**를 자동으로 생성하는 전략을 설정하며, `AUTO`, `IDENTITY`, `SEQUENCE`, `TABLE` 전략을 사용할 수 있습니다. **데이터베이스에 맞는 전략**을 선택해야 합니다.               | `@Id @GeneratedValue(strategy = GenerationType.IDENTITY)`                  |
| **`@Enumerated`**     | **Enum 타입** 필드를 데이터베이스에 매핑하며, **ORDINAL**(숫자) 또는 **STRING**(문자열) 방식으로 저장할 수 있습니다. **ORDINAL**은 문제를 일으킬 수 있으므로 **STRING**을 권장합니다. | `@Enumerated(EnumType.STRING) private UserRole role;`                      |


**관계 매핑 애너테이션:**

| **매핑 애너테이션**      | **설명**                                                           | **사용 예시**                                                                                         | **주의사항**                                                                       |
| ----------------- | ---------------------------------------------------------------- | ------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------ |
| **`@OneToOne`**   | **일대일(1:1)** 관계를 매핑.                                             | `@OneToOne @JoinColumn(name = "address_id")`                                                      | 관계의 **주인**을 명확히 설정해야 합니다. 주인이 아닌 쪽은 `mappedBy`를 사용하여 관계를 맺습니다. 기본적으로 즉시 로딩입니다. |
| **`@OneToMany`**  | **일대다(1:N)** 관계를 매핑.                                             | `@OneToMany(mappedBy = "owner", cascade = CascadeType.ALL, fetch = FetchType.LAZY)`               | `mappedBy`를 통해 **연관 관계의 주인**을 설정합니다. **지연 로딩(Lazy)**이 기본값입니다.                  |
| **`@ManyToOne`**  | **다대일(N:1)** 관계를 매핑.                                             | `@ManyToOne @JoinColumn(name = "owner_id")`                                                       | 기본적으로 **즉시 로딩(Eager Loading)**이므로, 필요에 따라 **지연 로딩**으로 설정하는 것이 좋습니다.            |
| **`@ManyToMany`** | **다대다(N:N)** 관계를 매핑. 두 엔티티가 **N:N**으로 서로 연관되며 **연결 테이블**이 필요합니다. | `@ManyToMany @JoinTable(name = "student_course", joinColumns = @JoinColumn(name = "student_id"))` | **연결 테이블**을 명시적으로 정의해야 하며, 성능과 복잡성 문제를 유발할 수 있으므로 주의가 필요합니다.                   |


### Cascade (영속성 전이)
한 엔티티의 상태 변화가 관련된 다른 엔티티에도 전파되도록 설정하는 기능
- 즉, **부모 엔티티**가 **저장**, **수정**, **삭제** 등의 작업을 할 때, **연관된 자식 엔티티**도 함께 그 작업을 처리할 수 있게 합니다.

| **Cascade 유형**        | **설명**                                                                           | **전이되는 메서드**              | **사용 예**                                                   |
| --------------------- | -------------------------------------------------------------------------------- | ------------------------- | ---------------------------------------------------------- |
| `CascadeType.PERSIST` | 부모 엔티티를 **저장**할 때 연관된 자식 엔티티도 함께 **저장**됩니다.                                      | `entityManager.persist()` | 부모 엔티티를 저장할 때, 자식 엔티티도 자동으로 저장될 필요가 있는 경우                  |
| `CascadeType.MERGE`   | 부모 엔티티를 **병합**할 때 연관된 자식 엔티티도 함께 **병합**됩니다.                                      | `entityManager.merge()`   | 부모와 자식 엔티티의 상태를 업데이트해야 하는 경우                               |
| `CascadeType.REMOVE`  | 부모 엔티티를 **삭제**할 때 연관된 자식 엔티티도 함께 **삭제**됩니다.                                      | `entityManager.remove()`  | 부모 엔티티를 삭제할 때 자식 엔티티도 함께 삭제해야 하는 경우 (예: 주문 삭제 시 주문 항목도 삭제) |
| `CascadeType.DETACH`  | 부모 엔티티를 **준영속** 상태로 만들 때, 연관된 자식 엔티티도 함께 **준영속** 상태가 됩니다.                        | `entityManager.detach()`  | 부모와 자식 엔티티를 영속성 컨텍스트에서 제거해야 할 때                            |
| `CascadeType.REFRESH` | 부모 엔티티가 **갱신**될 때 연관된 자식 엔티티도 함께 **갱신**됩니다.                                      | `entityManager.refresh()` | 부모와 자식 엔티티를 데이터베이스의 최신 상태로 동기화해야 할 때                       |
| `CascadeType.ALL`     | **모든 영속성 전이**(`PERSIST`, `MERGE`, `REMOVE`, `DETACH`, `REFRESH`) 작업을 한 번에 적용합니다. | 위의 모든 메서드                 | 부모-자식 관계에서 모든 상태 변화를 전이시켜야 할 때                             |

### 고아 객체(Orphan)란?

**고아 객체(Orphan Object)**는 JPA에서 **부모 엔티티와의 연관 관계가 끊어진 자식 엔티티**를 의미합니다. JPA에서는 이러한 고아 객체를 **자동으로 삭제**할 수 있는 기능을 제공합니다.

 **고아 객체 삭제 설정: `orphanRemoval = true`**
- 이 옵션은 `@OneToOne` 또는 `@OneToMany` 관계에서 사용할 수 있습니다.

**`orphanRemoval`과 `CascadeType.REMOVE`의 차이점**
- **`orphanRemoval = true`**: 부모 엔티티에서 자식 엔티티와의 **관계가 끊어질 때** 고아 객체를 자동으로 삭제합니다. 자식 엔티티가 **부모와의 연관 관계에서만 삭제**되면 발생합니다.
- **`CascadeType.REMOVE`**: 부모 엔티티를 **삭제할 때** 연관된 모든 자식 엔티티도 **함께 삭제**합니다.

**주의사항**
1. **고아 객체 삭제는 연관 관계에서만 적용**됩니다. 단순히 자식 엔티티를 직접 삭제하려고 할 때는 동작하지 않습니다. 부모 엔티티와의 관계를 끊어야 합니다.
2. **성능**: 많은 자식 엔티티를 가진 관계에서 고아 객체 삭제를 빈번하게 사용하면 개별 DELETE 쿼리 및 상태 추적으로 인해 성능에 영향을 미칠 수 있으므로 적절히 사용해야 합니다.
3. **양방향 연관관계**에서 부모와 자식의 관계 관리에 신경 써야 합니다. 자식 엔티티가 부모 엔티티와 제대로 연결되거나 해제되지 않으면 예상치 못한 결과가 발생할 수 있습니다.

### 페치 전략(Fetch Strategy)
엔티티 관계에서 데이터를 조회할 때 사용하는 방식

- **지연 로딩(Lazy Loading)**: 연관된 엔티티를 실제로 사용할 때 데이터베이스에서 조회합니다. 성능 최적화를 위해 사용되며, 필요한 시점에만 데이터를 로드합니다.
	- 주로 **프록시 객체**를 통해 구현합니다.
		- **엔티티가 로드될 때**: 주 엔티티(User)를 ID 기반으로 로드할 때 연관된 엔티티(Profile)는 데이터베이스에서 로드되지 않고, 대신 **프록시 객체**가 반환됩니다.
		- **엔티티 접근 시점**: 프록시 객체에 실제 접근이 발생하는 순간(예: `user.getProfile()`), 프록시 객체가 데이터베이스에 쿼리를 실행하여 **실제 엔티티 데이터를 로드**합니다.
		- **실제 엔티티로 변환**: 프록시 객체가 실제 엔티티로 대체되며, 그 이후로는 실제 엔티티 객체가 사용됩니다.
	- 주의사항
		- **영속성 컨텍스트가 닫힌 후**에 프록시 객체에 접근하면 **`LazyInitializationException`**이 발생합니다.
		- 프록시 객체는 **실제 엔티티 클래스가 아니므로**, 자바의 `instanceof` 연산자나 `equals()` 메서드 등에서 예상과 다른 동작을 할 수 있습니다.
			- 엔티티의 `equals()` 메서드에서 프록시 객체도 동일하게 처리되도록 **ID 기반 비교**로 수정하는 것이 일반적입니다.

- **즉시 로딩(Eager Loading)**: 연관된 엔티티를 함께 조회합니다. 엔티티를 조회할 때 즉시 관련된 데이터를 전부 불러옵니다.
	- 주의사항
		- 즉시 로딩은 **프록시 객체**를 사용하지 않기 때문에, 엔티티를 사용할 때마다 자동으로 로드되는 지연 로딩과 달리, **필요하지 않은 데이터까지 미리 로드**됩니다. 즉시 로딩을 사용할 때는 이러한 **과도한 로딩**을 주의해야 합니다.

### 락킹(Locking)
**락킹(Locking)** 은 여러 트랜잭션이 동시에 같은 데이터를 수정하려고 할 때 **동시성 제어**를 위해 사용됩니다.
- **낙관적 락(Optimistic Lock)**: 충돌이 거의 일어나지 않는 환경에서 사용하며, 수정이 완료될 때까지 데이터 충돌을 감지하지 않고, 수정 시점에서 충돌을 확인합니다. `@Version` 애너테이션을 사용해 버전 번호로 충돌을 감지합니다.
- **비관적 락(Pessimistic Lock)**: 데이터를 수정할 때 다른 트랜잭션이 접근하지 못하도록 아예 락을 거는 방식입니다.


# References
- https://www.youtube.com/watch?v=rYj8PLIE6-k
- 자바 ORM 표준 JPA 프로그래밍 - 김영한