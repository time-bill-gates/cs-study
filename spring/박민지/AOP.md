AOP(Aspect-Oriented Programming)는 **관점 지향 프로그래밍**을 의미하며, 소프트웨어 개발에서 핵심 로직 외에도 반복적으로 발생하는 공통적인 관심 사항(cross-cutting concerns)을 분리하여 관리할 수 있는 패러다임입니다.

### 목적
- **관심사의 분리 (Separation of Concerns)**: 비즈니스 로직과 상관없는 공통 기능(예: 로깅, 트랜잭션 관리, 보안)을 분리하여 모듈화함으로써, 핵심 로직이 불필요한 코드로 오염되지 않도록 한다.
- **중복 코드 제거**: 여러 클래스나 메서드에서 반복적으로 사용되는 로직(예: 인증, 검증, 예외 처리)을 한 곳에서 관리할 수 있어, 중복 코드를 줄이고 코드 유지보수를 쉽게 만든다.
- **유지보수성 향상**: 공통 기능을 별도의 애스펙트로 분리하여 관리하기 때문에, 코드 수정 시 핵심 비즈니스 로직을 건드리지 않고도 부가 기능을 수정하거나 확장할 수 있다.
- **투명한 코드 관리**: AOP를 사용하면 부가적인 관심사(로깅, 보안 등)가 핵심 비즈니스 로직과 분리되므로, 비즈니스 로직이 더 명확해지고 가독성이 높아진다.
- **일관성 보장**: 공통 기능을 여러 곳에서 일관되게 적용할 수 있어, 전역적인 정책(예: 전역적인 트랜잭션 처리나 로깅)을 쉽게 구현할 수 있다.

### 단점
- **복잡성 증가**: AOP는 코드의 흐름이 눈에 보이지 않는 방식으로 변경될 수 있으므로, 프로젝트의 복잡성이 증가할 수 있습니다. 특히, 많은 애스펙트가 사용될 경우 디버깅이 어려워질 수 있습니다.
- **코드 가독성 저하**: 핵심 로직 외부에서 애스펙트가 작동하기 때문에, 코드만 봐서는 어디서 어떤 로직이 실행되는지 파악하기 어려울 수 있습니다. 이는 코드 추적이 어렵고 가독성을 저하시킬 수 있습니다.
- **성능 오버헤드**: 런타임 시 프록시를 생성하여 애스펙트를 적용하므로, 추가적인 성능 오버헤드가 발생할 수 있습니다. 특히, 빈번한 메서드 호출이 있는 경우 성능에 영향을 줄 수 있습니다.
- **디버깅과 테스트 어려움**: AOP는 메서드 실행 전후에 자동으로 적용되기 때문에, 디버깅 시 예상치 못한 동작을 추적하기 어렵습니다. 테스트 또한 비즈니스 로직과 부가 로직을 별도로 확인해야 하므로 복잡해질 수 있습니다.
- **과도한 사용으로 인한 의존성 증가**: AOP를 지나치게 사용하면 시스템이 애스펙트에 의존하게 되어, 비즈니스 로직이 오히려 불투명해지고 유지보수에 어려움을 겪을 수 있습니다.
- **학습 곡선**: AOP는 기존 OOP(Object-Oriented Programming)에 익숙한 개발자들에게는 비교적 생소할 수 있으며, 특히 포인트컷 표현식과 Advice의 동작 방식을 이해하는 데 시간이 걸릴 수 있습니다.

### 주요 개념
- **Aspect (애스펙트)**: 공통적인 관심사를 모듈화한 것. 예를 들어, 로그를 기록하는 코드나 트랜잭션 관리 코드 등이 Aspect에 해당합니다.
- **Join Point (조인 포인트)**: 애플리케이션 실행 시점 중에서 Aspect를 적용할 수 있는 지점을 의미합니다. 메서드 호출, 예외 발생, 필드 값 변경 등이 Join Point에 해당합니다.
- **Advice (어드바이스)**: Join Point에서 실행될 코드, 즉 실제로 무엇을 할지 정의한 것입니다. Advice는 언제 실행되는지에 따라 여러 종류로 나뉩니다:
    - **Before**: 메서드 실행 전에 실행되는 Advice
    - **After**: 메서드 실행 후에 실행되는 Advice
    - **After Returning**: 메서드가 정상적으로 실행되고 반환된 후에 실행되는 Advice
    - **After Throwing**: 메서드에서 예외가 발생한 후에 실행되는 Advice
    - **Around**: 메서드 실행 전후 또는 예외가 발생했을 때 모두 실행 가능한 Advice
- **Pointcut (포인트컷)**: Aspect를 적용할 Join Point를 정의하는 표현식입니다. 특정 메서드나 클래스에만 Aspect를 적용할 수 있습니다.
- **Weaving (위빙)**: 실제로 Aspect와 핵심 비즈니스 로직이 연결되는 과정입니다. Spring에서는 런타임 시 프록시 객체를 생성하여 위빙을 수행합니다.

### AOP 구현 방식
#### 프록시 기반 AOP (Proxy-based AOP)
   Spring AOP는 기본적으로 **프록시 패턴**을 사용하여 런타임에 AOP를 적용합니다. 이는 스프링이 자동으로 프록시 객체를 생성하여 애스펙트를 적용할 수 있도록 해줍니다.
   - **JDK 동적 프록시**: Spring AOP는 인터페이스를 구현한 클래스에 대해서는 JDK의 동적 프록시(`java.lang.reflect.Proxy`)를 사용합니다.
   - **CGLIB 프록시**: 인터페이스를 구현하지 않은 클래스를 대상으로는 **CGLIB**(Code Generation Library)를 사용하여 프록시 객체를 생성합니다. 이 경우 클래스 자체를 상속받아 프록시 객체를 만듭니다.

   **프록시 기반 AOP의 특징**:
   - 주로 **런타임**에 프록시가 생성됩니다.
   - 메서드 호출 시 프록시 객체가 대신 호출을 받아 애스펙트를 적용하고, 실제 비즈니스 로직을 호출합니다.
   - **비침투적**이므로 기존의 코드에 큰 변경 없이 AOP를 적용할 수 있습니다.
   - JDK 동적 프록시를 사용할 경우, **프록시는 인터페이스 타입으로만 캐스팅**할 수 있으며 구체 클래스 타입으로 캐스팅할 수 없습니다. 예를 들어, 아래와 같은 경우 클래스 타입으로 캐스팅하면 예외가 발생할 수 있습니다.
   - CGLIB 프록시는 **클래스를 상속**하여 프록시 객체를 생성합니다. 그러나 `final`로 선언된 클래스나 메서드는 상속이 불가능하기 때문에 **AOP 적용이 불가**합니다.
   - 프록시 기반 AOP는 프록시 객체가 실제 객체를 감싸고 메서드 호출을 가로챌 때만 애스펙트가 적용됩니다. 따라서 **같은 클래스 내에서 메서드 간의 호출**에는 AOP가 적용되지 않습니다.

#### AspectJ 기반 AOP
   **AspectJ**는 강력한 AOP 구현을 위한 방법을 제공합니다. AspectJ는 **컴파일 타임**, **로드 타임**, **런타임**에 애스펙트를 적용할 수 있으며, 더 풍부한 포인트컷 표현식을 지원합니다.

   **AspectJ의 주요 특징**:
   - **컴파일 타임 위빙**: 소스 코드를 컴파일할 때 애스펙트를 적용합니다. 이 방식은 가장 빠르며, 애플리케이션의 성능에 영향을 최소화합니다.
   - **로드 타임 위빙**: 클래스가 JVM에 로드될 때 애스펙트가 적용됩니다. 이 방식은 실행 환경에서 동적으로 애스펙트를 추가할 수 있습니다.
   - **런타임 위빙**: Spring AOP와 유사하게 런타임에 애스펙트를 적용하지만, AspectJ는 더 강력한 기능을 제공합니다.

   - AspectJ는 전용 컴파일러와 설정이 필요하지만, 보다 강력한 AOP 기능을 제공합니다. Spring에서 AspectJ를 사용하려면 의존성을 추가하고 적절한 설정을 해야 합니다.
   - AspectJ는 Spring AOP보다 더 복잡한 포인트에서 위빙이 발생하므로, 디버깅이 더 어렵습니다. 예를 들어, 필드 접근이나 객체 생성 시 AOP가 적용되는 경우, 코드 흐름을 이해하거나 문제를 추적하는 데 어려움이 있을 수 있습니다.


